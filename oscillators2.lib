/* Mainly band-limited impulse train oscillators.
 *
 * Copyright (c) 2019, Dario Sanfilippo <sanfilippo.dario at gmail dot com> 
 *
 * All rights reserved.
 */

au = library("auxiliary.lib");
ba = library("basics.lib");
fi = library("filters.lib");
f2 = library("filters2.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
o2 = library("oscillators2.lib");

// bipolar BLIT
blit_bp(f, h, d) = m2.delta(10, d1, blit_up(f, h))
with {
      d1 = d*( 1,
               f : m2.div);
};

// unipolar BLIT
blit_up(f, h) = ba.if(phase : ==(0), 1, sinc)
with {
      sinc =   sin(phase*h_1),
               sin(phase) : m2.div, 
                            h_1 : m2.div;
      phase = ph(f_1, 0)*2*ma.PI;
      f_1 = f/2;
      h_1 = m2.diff(phase) : <(0),
            (h*2+1 : min(lim) : int) : ba.sAndH;
      lim = ba.if((int((ma.SR,
                       f : m2.div)) : %(2) : ==(0)), 
                   int((ma.SR,
                       f : m2.div))-1, 
                   int((ma.SR,
                       f : m2.div)));
};

// phasor with phase reset
ph(freq, reset) = freq/ma.SR : (+ : ma.decimal) 
                               ~ *(1-(reset : !=(0)));

// quadrature oscillator by Martin Vicanek
osc_quad(f) =  tick 
               ~ ( _, 
                   _)
with {
      init = 1-1';
      w1 = m2.w(f);
      k1 = tan(.5*w1);
      k2 = 2*k1/(1+k1*k1);
      tick(u, v) = omega-k1*(v+k2*omega), 
                   v+k2*omega
      with {
       omega = (u+init)-k1*v;
      };
};

// BLIT-based variable width pulse train
pulse_train(f, h, d) = blit_bp(f, h, d) : fi.pole(.9999) : *(scale) : +(d)
with {
      lim =    m2.ny,
               f : m2.div;
      scale =  lim,
               (h : min(lim)) : m2.div;
};

// BLIT-based saw
saw(f, h) = blit_up(f, h) <:   _,
                               f2.lp1p(1) : - : fi.pole(.9999) : *(scale)
with {
      lim =    m2.ny,
               f : m2.div;
      scale =  lim,
               (h : min(lim)) : m2.div;
};

// BLIT-based square
square(f, h) = blit_bp(f, h, .5) : fi.pole(.9999) : *(scale)
with {
      lim =    m2.ny,
               f : m2.div;
      scale =  lim,
               (h : min(lim)) : m2.div;
};
