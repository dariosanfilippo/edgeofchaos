// =============================================================================
// ========== oscillators2.lib =================================================
// =============================================================================
//
// This library contains band-limited oscillators with arbitrary harmonic 
// content for classic analogue waveforms such as sawtooth, square, 
// and triangle waves, as well as band-limited pulse-trains with arbitrary
// duty-cycles. The library includes a quadrature oscillator based on,
// arguably, the best recursive design available in the literature, and
// self-oscillating systems based on chaotic functions.
//
// The environment prefix is "o2".
//
// List of functions:
//
//    blit_bi,
//    blit_bi_duty,
//    blit_uni,
//    lorenz,
//    osc_quad,
//    ph,
//    pulse_train,
//    saw,
//    square,
//    tri.
//
// Copyright (c) 2019-2020, Dario Sanfilippo <sanfilippo.dario at gmail dot com>
// All rights reserved.

declare name "Oscillators Library";
declare author "Dario Sanfilippo";
declare copyright "Copyright (c) 2019-2020, Dario Sanfilippo <sanfilippo.dario
      at gmail dot com>";
declare version "1.0.0";
declare license "GPLv2.0";

au = library("auxiliary.lib");
ba = library("basics.lib");
fi = library("filters.lib");
f2 = library("filters2.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
os = library("oscillators.lib");
o2 = library("oscillators2.lib");

// o2.blit_bi(H[n], F[n]); -----------------------------------------------------
//
// Bipolar band-limited impulse train (BLIT) based on period sinc function. 
//
// The maximum harmonic number is given by:
//
//    rint(SR/frequency/4).
//
// The bipolar BLIT has no DC component and the number of harmonics include 
// the fundamental frequency and its odd multiples. Variations in the harmonic 
// content take place at the beginning of each cycle to avoid clicks. Hence, 
// changes will take place after a time that is the period of the BLIT or less.
//
// Unlike the technique described in [Stilson and Smith 1996] where the 
// bipolar BLIT is implemented by summation of a unipolar BLIT with its 
// delayed and inverted copy, the technique showed here uses an even ratio 
// between the frequencies of the sine functions used to generate the sinc, 
// which results in a correct harmonic content (odd harmonics) for any given 
// BLIT frequencies.
//
// The amplitude of the function, regardless of the harmonics, 
// is normalised to unit-amplitude peaks.
//
// 2 inputs:
//    H[n], (rounded to rint inside the asinc function) number of harmonics;
//    F[n], BLIT frequency in Hz.
//
// 1 outputs:
//    y[n], bipolar band-limited impulse train.
//
blit_bi(h, f) = m2.asinc_bi(h1, phase)
      with {
           lim = rint(ma.SR / f / 4);
           h1 = ba.sAndH(trigger, min(lim, h));
           trigger = (ma.signum(f) * (phase - phase') < 0);
           // Add au.dirac to "trigger" if you require the initial value
           // of H[n] to be triggered initially at n = 0.
           phase = os.phasor(1, f);
      };
// -----------------------------------------------------------------------------

// o2.blit_bi_duty(H[n], D[n], F[n]); ------------------------------------------
//
// Bipolar band-limited impulse train with arbitrary duty cycle
// following the paper by [Stilson and Smith 1996]:
//
// https://ccrma.stanford.edu/~stilti/papers/blit.pdf.
//
// The lowest frequency at which an entire duty cycle can be explored is
// 1 Hz. If lower frequencies are required, the first argument of
// m2.delta should be changed.
//
// 3 inputs:
//    H[n], (rounded to rint) number of harmonics;
//    D[n], duty cycle in the range [0; 1];
//    F[n], frequency of the BLIT in Hz.
//
// 1 outputs:
//    y[n], bipolar BLIT with arbitrary duty cycle.
//
blit_bi_duty(h, d, f) = m2.delta(1, d1, o2.blit_uni(h, f))
      with {
           d1 = d * m2.div(1, f);
      };
// -----------------------------------------------------------------------------

// o2.blit_uni(H[n], F[n]); ----------------------------------------------------
//
// The unipolar BLIT has a DC component and the number of harmonics include the 
// fundamental frequency and its multiples (both even and odd). 
//
// The technique described here is based on the paper by
// [Stilson and Smith 1996]:
//
// https://ccrma.stanford.edu/~stilti/papers/blit.pdf.
//
// The amplitude of the function, regardless of the harmonics, 
// is normalised to unit-amplitude peaks.
//
// 2 inputs:
//    H[n], (rounded to rint inside the asinc function) number of harmonics;
//    F[n], BLIT frequency in Hz.
//
// 1 outputs:
//    y[n], unipolar band-limited impulse train.
//
blit_uni(h, f) = m2.asinc_uni(h1, phase)
      with {
           lim = floor(ma.SR / f / 2);
           h1 = ba.sAndH(trigger, min(lim, h));
           trigger = (ma.signum(f) * (phase - phase') < 0);
           // Add au.dirac to "trigger" if you require the initial value
           // of H[n] to be triggered initially at n = 0.
           phase = os.phasor(1, f);
      };
// -----------------------------------------------------------------------------

// Lorenz system; ref: https://ijpam.eu/contents/2013-83-1/9/9.pdf
// arguments are: initial conditions for x, y, z; a, b, r, dt
// coeffcients.
// Try process = lorenz(1.2, 1.3, 1.6, 10, 8/3, 28, .005); for a strange
// attractor (way out of the -1-to-1 range)
lorenz(x0, y0, z0, a, b, r, dt) =   iterate
                                    ~ ( _ ,
                                        _ ,
                                        _)
      with {
           iterate(x, y, z) =  x1 + a * (y1 - x1) * dt,
                               y1 + (r * x1 - y1 - x1 * z1) * dt,
                               z1 + (x1 * y1 - b * z1) * dt
           with {
               x1 = x + x0 - x0';
               y1 = y + y0 - y0';
               z1 = z + z0 - z0';
           };
      };

// quadrature oscillator by Martin Vicanek
osc_quad(f) =  tick 
               ~ ( _ , 
                   _)
      with {
           k1 = tan(ma.PI * f / ma.SR);
           k2 = 2 * k1 / (1 + k1 * k1);
           tick(u, v) =    omega - k1 * (v + k2 * omega) , 
                           v + k2 * omega
           with {
               omega = (u + au.dirac) - k1 * v;
           };
      };

// phasor with phase reset
ph(freq, reset) = freq / ma.SR * r :   (+ : ma.decimal)
                                       ~ * (r)
      with {
           r = 1 - (reset != 0);
      };

// BLIT-based variable width pulse train
pulse_train(h, d, f) = blit_bi_duty(h, d, f) : f2.leaky(.1 / m2.twopi) / 
      scale + d
      with {
           lim = rint(ma.SR / f / 2);
           scale = m2.div(lim, min(lim, h)) : si.smooth(ba.tau2pole(.1));
      };

// BLIT-based saw
saw(h, f) = blit_uni(h, f) <: _ - f2.lp1p(f / 100) : f2.leaky(.1 / m2.twopi) / 
      scale : fi.highpass(1, 20)
      with {
           lim = floor(ma.SR / f / 2);
           scale = m2.div(lim, (2 * min(lim, h))) : si.smooth(ba.tau2pole(.1));
      };

// BLIT-based square
square(h, f) = blit_bi(h, f) : f2.leaky(.1 / m2.twopi) / scale : 
      fi.highpass(1, 20)
      with {
           lim = rint(ma.SR / f / 4);
           scale = m2.div(lim, (2 * min(lim, h))) : si.smooth(ba.tau2pole(.1));
      };

// BLIT-based triangle
tri(h, f) = square(h, f) : leaky / scale : fi.highpass(1, 20)
      with {
           leaky = fi.pole(ba.tau2pole(.1 / m2.twopi));
           scale = rint(ma.SR / f / 4) : si.smooth(ba.tau2pole(.1));
      };
