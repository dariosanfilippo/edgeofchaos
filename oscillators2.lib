// =============================================================================
// ========== oscillators2.lib =================================================
// =============================================================================
//
// This library contains band-limited oscillators with arbitrary harmonic 
// content for classic analogue waveforms such as sawtooth, square, 
// and triangle waves, as well as band-limited pulse-trains with arbitrary
// duty-cycles. The library includes a quadrature oscillator based on,
// arguably, the best recursive design available in the literature, and
// self-oscillating systems based on chaotic functions.
//
// The environment prefix is "o2".
//
// List of functions:
//
//    blit_bi,
//    blit_bi_duty,
//    blit_uni,
//    eca,
//    lorenz,
//    osc_quad,
//    ph,
//    pulse_train,
//    saw,
//    square,
//    tri.
//
// Copyright (c) 2019-2020, Dario Sanfilippo <sanfilippo.dario at gmail dot com>
// All rights reserved.

declare name "Oscillators Library";
declare author "Dario Sanfilippo";
declare copyright "Copyright (c) 2019-2020, Dario Sanfilippo <sanfilippo.dario
      at gmail dot com>";
declare version "1.0.0";
declare license "GPLv2.0";

au = library("auxiliary.lib");
ba = library("basics.lib");
fi = library("filters.lib");
f2 = library("filters2.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
os = library("oscillators.lib");
o2 = library("oscillators2.lib");

// o2.blit_bi(H[n], F[n]); -----------------------------------------------------
//
// Bipolar band-limited impulse train (BLIT) based on period sinc function. 
//
// The maximum harmonic number is given by:
//
//    rint(SR/frequency/4).
//
// The bipolar BLIT has no DC component and the number of harmonics include 
// the fundamental frequency and its odd multiples. Variations in the harmonic 
// content take place at the beginning of each cycle to avoid clicks. Hence, 
// changes will take place after a time that is the period of the BLIT or less.
//
// Unlike the technique described in [Stilson and Smith 1996] where the 
// bipolar BLIT is implemented by summation of a unipolar BLIT with its 
// delayed and inverted copy, the technique showed here uses an even ratio 
// between the frequencies of the sine functions used to generate the sinc, 
// which results in a correct harmonic content (odd harmonics) for any given 
// BLIT frequencies.
//
// The amplitude of the function, regardless of the harmonics, 
// is normalised to unit-amplitude peaks.
//
// 2 inputs:
//    H[n], (rounded to rint inside the asinc function) number of harmonics;
//    F[n], BLIT frequency in Hz.
//
// 1 outputs:
//    y[n], bipolar band-limited impulse train.
//
blit_bi(h, f) = m2.asinc_bi(h1, phase)
      with {
           lim = rint(m2.div(ma.SR, f) / 4);
           h1 = ba.sAndH(trigger, min(lim, h));
           trigger = (ma.signum(f) * (phase - phase') < 0);
           // Add au.dirac to "trigger" if you require the initial value
           // of H[n] to be triggered initially at n = 0.
           phase = os.phasor(1, f);
      };
// -----------------------------------------------------------------------------

// o2.blit_bi_duty(H[n], D[n], F[n]); ------------------------------------------
//
// Bipolar band-limited impulse train with arbitrary duty cycle
// following the paper by [Stilson and Smith 1996]:
//
// https://ccrma.stanford.edu/~stilti/papers/blit.pdf.
//
// The lowest frequency at which an entire duty cycle can be explored is
// 1 Hz. If lower frequencies are required, the first argument of
// m2.delta should be changed.
//
// 3 inputs:
//    H[n], (rounded to rint) number of harmonics;
//    D[n], duty cycle in the range [0; 1];
//    F[n], frequency of the BLIT in Hz.
//
// 1 outputs:
//    y[n], bipolar BLIT with arbitrary duty cycle.
//
blit_bi_duty(h, d, f) = m2.delta(1, d1, o2.blit_uni(h, f))
      with {
           d1 = d * m2.div(1, f);
      };
// -----------------------------------------------------------------------------

// o2.blit_uni(H[n], F[n]); ----------------------------------------------------
//
// The unipolar BLIT has a DC component and the number of harmonics include the 
// fundamental frequency and its multiples (both even and odd). 
//
// The technique described here is based on the paper by
// [Stilson and Smith 1996]:
//
// https://ccrma.stanford.edu/~stilti/papers/blit.pdf.
//
// The amplitude of the function, regardless of the harmonics, 
// is normalised to unit-amplitude peaks.
//
// 2 inputs:
//    H[n], (rounded to rint inside the asinc function) number of harmonics;
//    F[n], BLIT frequency in Hz.
//
// 1 outputs:
//    y[n], unipolar band-limited impulse train.
//
blit_uni(h, f) = m2.asinc_uni(h1, phase)
      with {
           lim = floor(m2.div(ma.SR, f) / 2);
           h1 = ba.sAndH(trigger, min(lim, h));
           trigger = (ma.signum(f) * (phase - phase') < 0);
           // Add au.dirac to "trigger" if you require the initial value
           // of H[n] to be triggered initially at n = 0.
           phase = os.phasor(1, f);
      };
// -----------------------------------------------------------------------------

// o2.eca(L, R, I, rate[n]); ---------------------------------------------------
//
// One-dimension, two-state, elementary cellular automata with circular
// lattice. The function is defined by the length of the lattice, a rule, and 
// an initial condition. Additionally, the function has a "rate" parameter 
// that determines the interval between iterations. The rule and the initial
// condition are positive INTs that are converted into binary numbers and
// accordingly zero-padded or limited to reach a binary string of 
// appropriate length.
//
// Ref: 
//    Wolfram, S. (1984). Cellular automata as models of complexity. Nature, 
//    311(5985), 419-424.
//
//    Wolfram, S. (2018). Cellular automata and complexity: collected papers. 
//    CRC Press.
//
// 1 inputs:
//    rate[n], iteration rate.
//
// L outputs:
//    y1[n];
//    y2[n];
//    ...;
//    yL[n], states of the cells in the lattice.
//
// 3 compile-time arguments:
//    L, (positive INT) size of the lattice (number of cells);
//    R, (positive INT up to 255) rule applied to the 8 possible cases;
//    I, (positive INT) initial condition for the cells.
//
eca(L, R, I, rate) =   (   si.bus(L) , 
                           init(I) : ro.interleave(L, 2) : par(i, L, +) : 
      iterate : par(i, L, ba.sAndH(trigger))) 
                       ~ si.bus(L)
      with {
           trigger = ba.period(ma.SR / max(ma.EPSILON, rate)) == 0;
           wrap(M, N) = int(ma.frac(N / M) * M);
           w_num = m2.zeropad_up(int(8 - ceil(ma.log2(R1))), m2.dec2bin(R1))
               with {
                   R1 = min(255, R);
               };
           init(N) = zeropad(int(L - ceil(ma.log2(N1))), dec2bin(N1)) : 
               par(i, L, _ <: _ - mem)
               with {
                   N1 = min(N, 2 ^ L - 1);
               };
           rule(x1, x2, x3) =
      ba.if(   c1, w_num : route(8, 1, 1, 1), 
           ba.if(  c2, w_num : route(8, 1, 2, 1), 
               ba.if(  c3, w_num : route(8, 1, 3, 1),
                   ba.if(  c4, w_num : route(8, 1, 4, 1),
                       ba.if(  c5, w_num : route(8, 1, 5, 1),
                           ba.if(  c6, w_num : route(8, 1, 6, 1),
                               ba.if(  c7, w_num : route(8, 1, 7, 1), 
                                   w_num : route(8, 1, 8, 1))))))))
                with {
                    c1 = (x1 == 1) & (x2 == 1) & (x3 == 1);
                    c2 = (x1 == 1) & (x2 == 1) & (x3 == 0);
                    c3 = (x1 == 1) & (x2 == 0) & (x3 == 1);
                    c4 = (x1 == 1) & (x2 == 0) & (x3 == 0);
                    c5 = (x1 == 0) & (x2 == 1) & (x3 == 1);
                    c6 = (x1 == 0) & (x2 == 1) & (x3 == 0);
                    c7 = (x1 == 0) & (x2 == 0) & (x3 == 1);
                    c8 = (x1 == 0) & (x2 == 0) & (x3 == 0);
                };
        iterate = si.bus(L) <: 
            par(i, L, route(L, 3,   wrap(L, i - 1) + 1, 1,
                                    i + 1, 2,
                                    wrap(L, i + 1) + 1, 3) : int(rule));
    };
// -----------------------------------------------------------------------------

// o2.lorenz(x0, y0, z0, a[n], b[n], r[n], dt[n]); -----------------------------
//
// Lorenz system: chaotic recursive system of differential equations.
//
// Ref: https://ijpam.eu/contents/2013-83-1/9/9.pdf.
//
// Try process = o2.lorenz(1.2, 1.3, 1.6, 10, 8/3, 28, .005); for a strange
// attractor (way out of the [-1; 1] range).
//
// 7 inputs:
//    x0, initial condition for the first equation (0 for n != 0);
//    y0, initial condition for the second equation (0 for n != 0);
//    z0, initial condition for the third equation (0 for n != 0);
//    a[n], coefficient in the first equation;
//    b[n], coefficient in the third equation;
//    r[n], coefficient in the second equation;
//    dt[n], discrete time interval.
//
// 3 output:
//    y1[n], first equation;
//    y2[n], second equation;
//    y3[n], third equation.
//
lorenz(x0, y0, z0, a, b, r, dt) =   iterate
                                    ~ ( _ ,
                                        _ ,
                                        _)
      with {
           iterate(x, y, z) =  x1 + a * (y1 - x1) * dt,
                               y1 + (r * x1 - y1 - x1 * z1) * dt,
                               z1 + (x1 * y1 - b * z1) * dt
           with {
               x1 = x + x0 - x0';
               y1 = y + y0 - y0';
               z1 = z + z0 - z0';
           };
      };
// -----------------------------------------------------------------------------

// o2.osc_quad(F[n]); ----------------------------------------------------------
//
// Recursive quadrature oscillator by Martin Vicanek. This design is
// arguably the best recursive quadrature oscillator available in the
// literature. The system shows long-term stability as well as accuracy at
// low frequencies. 
//
// Ref: https://vicanek.de/articles/QuadOsc.pdf.
//
// 1 inputs:
//    F[n], oscillator frequency in Hz.
//
// 2 outputs:
//    y1[n], cosine (real part);
//    y2[n], sine (imaginary part).
//
osc_quad(f) =  tick 
               ~ ( _ , 
                   _)
      with {
           k1 = tan(ma.PI * f / ma.SR);
           k2 = 2 * k1 / (1 + k1 * k1);
           tick(u, v) =    omega - k1 * (v + k2 * omega) , 
                           v + k2 * omega
           with {
               omega = (u + au.dirac) - k1 * v;
           };
      };
// -----------------------------------------------------------------------------

// o2.ph(F[n], R[n]); ----------------------------------------------------------
//
// Phasor with reset input.
//
// Note: the arguments of the function should be inverted for
// consistency, but that requires checking for backward compatibility.
//
// 2 inputs:
//    F[n], frequency in Hz;
//    R[n], reset phasor to zero if R[n] != 0.
//
// 1 outputs:
//    y[n], phasor output.
//
ph(freq, reset) =  (+ (freq / ma.SR * r) : ma.decimal)
                   ~ * (r)
      with {
           r = reset == 0;
      };
// -----------------------------------------------------------------------------

// o2.pulse_train(H[n], D[n], F[n]); -------------------------------------------
//
// BLIT-based variable width pulse train. Implemented following
// [Stilson and Smith 1996]:
//
// https://ccrma.stanford.edu/~stilti/papers/blit.pdf.
//
// 3 inputs:
//    H[n], number of harmonics, both even and odd, cast to the closest
//             INT and phase-locked to the beginning of each cycle. The harmonic
//             content is affected by the duty cycle;
//    D[n], duty cycle in the range [0; 1];
//    F[n], pulse train frequency in Hz.
//
// 1 outputs:
//    y[n], band-limited pulse train.
//
pulse_train(h, d, f) = 
      blit_bi_duty(h, d, f) : m2.div(f2.leaky(.1 / m2.twopi), scale) + d
      with {
           lim = rint(m2.div(ma.SR, f) / 2);
           scale = m2.div(lim, min(lim, h)) : si.smooth(ba.tau2pole(.1));
      };
// -----------------------------------------------------------------------------

// o2.saw(H[n], F[n]); ---------------------------------------------------------
//
// BLIT-based band-limited sawtooth oscillator.
//
// This function is based on [Stilson and Smith 1996], although the
// scaling factor for a unit-amplitude normalisation has been determined by 
// the author.
//
// Ref: https://ccrma.stanford.edu/~stilti/papers/blit.pdf.
//
// 2 inputs:
//    H[n], number of harmonics (both even and odd), cast to the closest INT;
//    F[n], frequency of the oscillator in Hz.
//
// 1 outputs:
//    y[n], band-limited sawtooth oscillator.
//
saw(h, f) = blit_uni(h, f) <: _ - f2.lp1p(f / 100) : 
      m2.div(f2.leaky(.1 / m2.twopi), scale) : fi.highpass(1, 20)
      with {
           lim = floor(m2.div(ma.SR, f) / 2);
           scale = m2.div(lim, (2 * min(lim, h))) : si.smooth(ba.tau2pole(.1));
      };
// -----------------------------------------------------------------------------

// o2.square(H[n], F[n]); ------------------------------------------------------
//
// BLIT-based band-limited square oscillator. This technique implements
// the integration of a bipolar BLIT. The bipolar BLIT is based on a sinc
// function with even ratios between the sine functions used in sinc, which
// result in a more precise harmonic content throughout the entire
// frequency range. The scaling factor normalises the output to unit
// amplitude for all frequencies and harmonics.
//
// 2 inputs:
//    H[n], number of harmonics (odd), cast to the closest
//             INT and phase-locked to the beginning of each cycle.
//    F[n], frequency of the oscillator in Hz.
//
// 1 outputs:
//    y[n], band-limited square oscillator.
//
square(h, f) = blit_bi(h, f) : m2.div(f2.leaky(.1 / m2.twopi), scale) : 
      fi.highpass(1, 20)
      with {
           lim = rint(m2.div(ma.SR, f) / 4);
           scale = m2.div(lim, (2 * min(lim, h))) : si.smooth(ba.tau2pole(.1));
      };
// -----------------------------------------------------------------------------

// o2.triangle(H[n], F[n]); ----------------------------------------------------
//
// BLIT-based band-limited triangle oscillator. This technique implements
// the integration of a BLIT-based square wave. The bipolar BLIT in the square 
// wave is based on a sinc function with even ratios between the sine functions 
// used in sinc, which result in a more precise harmonic content throughout 
// the entire frequency range. The scaling factor normalises the output to unit
// amplitude for all frequencies and harmonics
//
// 2 inputs:
//    H[n], number of harmonics (odd), cast to the closest
//             INT and phase-locked to the beginning of each cycle.
//    F[n], frequency of the oscillator in Hz.
//
// 1 outputs:
//    y[n], band-limited triangle oscillator.
//
triangle(h, f) = square(h, f) : m2.div(f2.leaky(.1 / m2.twopi), scale) : 
      fi.highpass(1, 20)
      with {
           scale = rint(m2.div(ma.SR, f) / 4) : si.smooth(ba.tau2pole(.1));
      };
// -----------------------------------------------------------------------------
