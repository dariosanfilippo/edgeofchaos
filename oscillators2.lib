// MORE OSCILLATORS

au = library("auxiliary.lib");
ba = library("basics.lib");
fi = library("filters.lib");
f2 = library("filters2.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
o2 = library("oscillators2.lib");

// phasor with phase reset
ph(freq, reset) = freq/ma.SR : (+ : ma.decimal) ~ *(1-(reset : !=(0)));

// unipolar BLIT
blit_up(f, h) = ba.if(phase : ==(0), 1, sinc)
with {
      sinc =   sin(phase*h_1),
               sin(phase) : m2.div, 
                            h_1 : m2.div;
      phase = ph(f_1, 0)*2*ma.PI;
      f_1 = f/2;
      h_1 = m2.diff(phase) : <(0),
            (h*2+1 : min(lim) : int) : ba.sAndH;
      lim = ba.if( (int(ma.SR/f) : %(2) : ==(0)), 
                   int(ma.SR/f)-1, 
                   int(ma.SR/f));
};

// bipolar BLIT
blit_bp(f, h, d) = m2.delta(10, d1, blit_up(f, h))
with {
      d1 = d*(1/f);
};

saw(f, h) = blit_up(f, h) <:   _,
                               f2.lp1p(1) : - : fi.pole(.9999) : *(scale)
with {
      lim = m2.ny/f;
      scale = lim/(h : min(lim));
};

square(f, h) = blit_bp(f, h, .5) : fi.pole(.9999) : *(scale)
with {
      lim = m2.ny/f;
      scale = lim/(h : min(lim));
};

pulse_train(f, h, d) = blit_bp(f, h, d) : fi.pole(.9999) : *(scale) : +(d)
with {
      lim = m2.ny/f;
      scale = lim/(h : min(lim));
};
