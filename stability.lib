/* Stability processing functions including standard dynamics processing as well as 
 * self-regulating designs.
 *
 * Copyright (c) 2019-2020, Dario Sanfilippo <sanfilippo.dario at gmail dot com> 
 *
 * All rights reserved.
 */

ba = library("basics.lib");
d2 = library("delays2.lib");
f2 = library("filters2.lib");
ip = library("information.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
ro = library("routes.lib");
si = library("signals.lib");
st = library("stability.lib");

// hard clipping
clip(lower, upper, in) = in : max(lower) : min(upper);

// cubic nonlinear distortion
cubic(x) = select3( cond,   -2/3,
                            x-(x*x*x/3),
                            2/3)
with {
    cond =  (   (x : >(-1)),
                (x : <(1)) : &),
            (x : >=(1))*2 :> _;
};

// dynamical compression based on peak
dyn_comp_peak(release, curve, in) =    in,
                                       (1-min(ip.peak_env(release, in), 1) 
                                           : pow(curve)) : *;

// dynamical compression based on RMS
dyn_comp_rms(window, curve, in) =  in,
                                   (1-min(ip.rms(window, in), 1)
                                       : pow(curve)) : *;

// dynamical normalisation based on peak
dyn_norm_peak(release, target, input) = input*ratio
with {
      ratio =  ip.peak_env(release, target),
               ip.peak_env(release, input) : m2.div;
};

// dynamical normalisation based on RMS
dyn_norm_rms(window, target, input) = input*ratio
with {
      ratio =  ip.rms(window, target),
               ip.rms(window, input) : m2.div;
};

// hyperbolic saturator
hyperbolic(x) = x/(1+abs(x));

// Simple lookahead limiter based on IOhannes Zm√∂lnig post, which is in
// turn based on the thesis by Peter Falkner "Entwicklung eines digitalen 
// Stereo-Limiters mit Hilfe des Signalprozessors DSP56001".
// This version of the limiter simply uses a peak-holder with smoothed
// attack and release based on e^(-2pi) time constant filters.
// This time constant allows for the amplitude profile to reach 1 -
// e^(-2pi) of the final peak after the attack time. The input path
// can be delayed by the same amount as attack time to synchronise input and
// amplitude profile, or by any other lookahead time specified by the user.
//
// #### Usage
//
// ```
// _ : limiter_basic_mono(lag, threshold, attack, hold, release) : _;
// ```
//
// Where:
//
// * `lag` lookahead delay in seconds.
// * `threshold` is the linear amplitude limiting threshold.
// * `attack` is the attack time in seconds. 
// * `hold` is hold time in seconds.
// * `release` is release time in seconds.
//
// Example: limiter_basic_mono(.01, 1, .01, .1, 1);
//
// #### Reference:
//
// http://iem.at/~zmoelnig/publications/limiter/.
//-----------------------------------------------------------------------------
limiter_lookahead(lag, threshold, attack, hold, release, x) =
      x @ (lag * ma.SR) * scaling
with {
      scaling = threshold / amp_profile : min(1);
      amp_profile = ip.peak_hold(hold, x) : att_smooth(attack) :
       rel_smooth(release);
      att_smooth(time, in) = f2.lp1p(1 / time, in);
      rel_smooth(time, in) = ip.peak_env(time, in);
};

// N-channel limiter based on the above algorithm. The scaling factor
// applied to all channels is based on the peak between them all.
limiter_lookaheadN(N, lag, threshold, attack, hold, release) =
      si.bus(N) <: par(i, N, @ (lag * ma.SR)) ,
                   (scaling <: si.bus(N)) : ro.interleave(N, 2) : par(i, N, *)
with {
      scaling =    threshold ,
                   amp_profile : / : min(1);
      amp_profile = par(i, N, abs) : m2.maxN(N) : ip.peak_hold(hold) : 
       att_smooth(attack) : rel_smooth(release);
      att_smooth(time, in) = f2.lp1p(1 / time, in);
      rel_smooth(time, in) = ip.peak_env(time, in);
};

// Lookahead limiter special case (mono).
limiter(lim, in) = limiter_lookahead(.002, 1, .002, .1, 1, in);

// parabolic saturator
parabolic(x) = ba.if(abs(x) : >=(2),    ma.signum(x),
                                        x*(1-abs(x/4)));

// sin(arctan(x))
sinatan(x) = x/sqrt(1+x*x);

// hyperbolic tangent (I mainly needed this for a test on the web editor; 
// you may want to use ma.tanh)
tanh(x) = (exp(2*x)-1)/(exp(2*x)+1);
