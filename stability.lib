/* Stability processing functions including standard dynamics processing as well as 
 * self-regulating designs.
 *
 * Copyright (c) 2019, Dario Sanfilippo <sanfilippo.dario at gmail dot com> All rights reserved.
 */

ba = library("basics.lib");
d2 = library("delays2.lib");
f2 = library("filters2.lib");
ip = library("information.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
st = library("stability.lib");

// hard clipping
clip(lower, upper, in) = in : max(lower) : min(upper);

// cubic nonlinear distortion
cubic(x) = select3( cond,   -2/3,
                            x-(x*x*x/3),
                            2/3)
with {
    cond =  (   (x : >(-1)) ,
                (x : <(1)) : &) ,
            (x : >=(1))*2 :> _;
};

// dynamical compression based on RMS
dyn_comp_rms(curve, window, in) =  in ,
                                   (   1 ,   
                                       (ip.rms(window, in) :   clip(0, 1) ,
                                                               curve : pow) : -) : *;

// dynamical normalisation based on peak
dyn_norm_peak(ref, release, target) = (ref ,
                                       target ,
                                       release) :  norm_fact_peak ,
                                                   target : *;

// dynamical normalisation based on RMS
dyn_norm_rms(ref, window, target) = (ref ,
                                    target ,
                                    window) :   norm_fact_rms ,
                                                target : *;

// hyperbolic saturator
hyperbolic(x) = x/(1+abs(x));

// look-ahead limiting
limiter(lim, in) = d2.del(.002, .002, in),
                   (   lim ,
                       (in : ip.peak_hold(.1) : f2.lp1p(500) : ip.peak_env(1)) : m2.div : min(1)) : *;

// reference_peak-input_peak ratio (with release parameter)
norm_fact_peak(ref, release, target) = (   release,
                                           ref : ip.peak_env) ,
                                       (   release ,
                                           target : ip.peak_env) : m2.div;

// reference_power-input_power ratio (with responsiveness parameter)
norm_fact_rms(ref, window, target) =  (   window,
                                           ref : ip.rms) ,
                                       (   window,
                                           target : ip.rms) : m2.div;

// parabolic saturator
parabolic(x) = ba.if(abs(x) : >=(2),    ma.signum(x),
                                        x*(1-abs(x/4)));

// sin(arctan(x))
sinatan(x) = x/sqrt(1+x*x);

// hyperbolic tangent (I mainly needed this for a test on the web editor; you may want to use ma.tanh)
tanh(x) = (exp(2*x)-1)/(exp(2*x)+1);
