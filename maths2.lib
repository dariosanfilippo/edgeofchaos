// =============================================================================
// ========== maths2.lib =======================================================
// =============================================================================
// 
// Math library containing functions for statistics, linear and nonlinear
// fuzzy logic, interpolators, network topologies, matrixes, linear and
// nonlinear mapping, windowing functions, hysteresis, angular frequency,
// and several time constants for exponential decays in one-pole systems.
// 
// The environment prefix is "m2".
// 
// List of functions:
// 
//       aad, 
//       avg_ari, 
//       avg_ari_w, 
//       avg_geo, 
//       avg_geo_w, 
//       avg_harm, 
//       avg_harm_w, 
//       avg_pow, 
//       avg_quad, 
//       bip, 
//       complement, 
//       delta, 
//       delta2, 
//       diff, 
//       div, 
//       hp_and, 
//       hp_imp, 
//       hp_nand, 
//       hp_nimp, 
//       hp_nor, 
//       hp_nxr, 
//       hp_or, 
//       hp_xor, 
//       interpolate_mn, 
//       if, 
//       ifN, 
//       inv, 
//       line, 
//       line_reset, 
//       map_lin, 
//       map_par, 
//       map_pcw, 
//       map_log, 
//       map_pow, 
//       matrix, 
//       maxN, 
//       minN, 
//       ny, 
//       ph, 
//       primes, 
//       prime_base_pow, 
//       relay_hysteron, 
//       round_pow2, 
//       rt9, 
//       rt19, 
//       rt55, 
//       rt60, 
//       sd, 
//       sp, 
//       topologies, 
//       top_anti_diag, 
//       top_diagonal, 
//       top_diag_shift, 
//       top_full, 
//       top_tri_low, 
//       top_tri_up, 
//       uni, 
//       unit_log, 
//       var, 
//       w, 
//       window_hann, 
//       window_sine, 
//       wrap, 
//       y_and, 
//       y_or, 
//       z_and, 
//       z_imp, 
//       z_nand, 
//       z_nimp, 
//       z_nor, 
//       z_nxr, 
//       z_or, 
//       z_xor.
//
// Copyright (c) 2019-2020, Dario Sanfilippo <sanfilippo.dario at gmail dot com>
// All rights reserved.

declare name "Math Library";
declare author "Dario Sanfilippo";
declare copyright "Copyright (c) 2019-2020, Dario Sanfilippo <sanfilippo.dario
      at gmail dot com>";
declare version "1.0.0";
declare license "GPLv2.0";

ba = library("basics.lib");
de = library("delays.lib");
d2 = library("delays2.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
ro = library("routes.lib");
si = library("signals.lib");

// m2.aad(N); ------------------------------------------------------------------
//
// Normalised average absolute deviation around the mean.
//
// N inputs:
//    x1[n];
//    ...
//    xN-1[n];
//    xN[n].
//
// 1 outputs:
//    y[n], average absolute deviation in the range [0; 1] of the input signals.
//
// Compile-time arguments:
//    N, (integer) number of input signals.
//
aad(N) = si.bus(N) <:  (si.bus(N) ,
                       (si.bus(N) :> / (N) <: si.bus(N)) : ro.interleave(N, 2) : 
      par(i, N, (- : abs)) :> _) ,
      (si.bus(N) :> / (N)) : m2.div : / ((N - 1) * 2);
// -----------------------------------------------------------------------------

// m2.avg_ari(N); --------------------------------------------------------------
//
// Arithmetic mean.
//
// N inputs:
//    x1[n];
//    ...
//    xN-1[n];
//    xN[n].
//
// 1 outputs:
//    y[n], arithmetic mean of the input signals.
//
// Compile-time arguments:
//    N, (integer) number of input signals.
//
avg_ari(N) = si.bus(N) :> / (N);
// -----------------------------------------------------------------------------

// m2.avg_ari_w(N); ------------------------------------------------------------
//
// Weighted arithmetic mean.
//
// 2N inputs:
//    x1[n];
//    ...
//    xN-1[n];
//    xN[n], input signals;
//    w1[n];
//    ...
//    wN-1[n];
//    wN[n], corresponding weighting signals.
//
// 1 outputs:
//    y[n], weighted arithmetic mean of the input signals.
//
// Compile-time arguments:
//    N, (integer) number of input signals and corresponding weighting
//         signals.
//
avg_ari_w(N) = si.bus(N) ,
               (si.bus(N) <:   si.bus(N) ,
                               (si.bus(N) :> _)) : 
      ro.interleave(N, 2) , 
      _ :  (par(i, N, *) :> _) / _;
// -----------------------------------------------------------------------------

// m2.avg_geo(N); --------------------------------------------------------------
//
// Geometric mean.
//
// N inputs:
//    x1[n];
//    ...
//    xN-1[n];
//    xN[n].
//
// 1 outputs:
//    y[n], geometric mean of the input signals.
//
// Compile-time arguments:
//    N, (integer) number of input signals.
//
avg_geo(N) = prod(i, N, _) : pow(1 / N);
// -----------------------------------------------------------------------------

// m2.avg_geo_w(N); ------------------------------------------------------------
//
// Weighted geometric mean.
//
// 2N inputs:
//    x1[n];
//    ...
//    xN-1[n]; 
//    xN[n], input signals;
//    w1[n];
//    ...
//    wN-1[n];
//    wN[n], corresponding weighting signals.
//
// 1 outputs:
//    y[n], weighted geometric mean of the input signals.
//
// Compile-time arguments:
//    N, (integer) number of input signals and corresponding weighting
//         signals.
//
avg_geo_w(N) = (si.bus(N) : par(i, N, log)) ,
               (si.bus(N) <:   si.bus(N) ,
                               (si.bus(N) :> _)) : 
      ro.interleave(N, 2) ,
      _ :  (par(i, N, *) :> _) / _ : exp;
// -----------------------------------------------------------------------------

// m2.avg_harm(N); -------------------------------------------------------------
//
// Harmonic mean.
//
// N inputs:
//    x1[n];
//    ...
//    xN-1[n];
//    xN[n].
//
// 1 outputs:
//    y[n], harmonic mean of the input signals.
//
// Compile-time arguments:
//    N, (integer) number of input signals.
//
avg_harm(N) = si.bus(N) : par(i, N, ma.inv) :> N / _;

// m2.avg_harm_w(N); -----------------------------------------------------------
//
// Weighted harmonic mean.
//
// 2N inputs:
//    x1[n];
//    ...
//    xN-1[n]; 
//    xN[n], input signals;
//    w1[n];
//    ...
//    wN-1[n];
//    wN[n], corresponding weighting signals.
//
// 1 outputs:
//    y[n], weighted harmonic mean of the input signals.
//
// Compile-time arguments:
//    N, (integer) number of input signals and corresponding weighting
//         signals.
//
avg_harm_w(N) =    (si.bus(N) : par(i, N, ma.inv)) ,
                   (si.bus(N) <:   si.bus(N) ,
                                   (si.bus(N) :> _)) :
      ro.interleave(N, 2) ,
      _ :  (par(i, N, *) :> _) / _ : ma.inv;
// -----------------------------------------------------------------------------

// m2.avg_pow(N, E[n]); --------------------------------------------------------
//
// Generalised mean.
//
// N+1 inputs:
//    E[n], exponent for each element in the set;
//    x1[n];
//    ...
//    xN-1[n];
//    xN[n].
//
// 1 outputs:
//    y[n], generalised mean of a set of N elements.
//
// Compile-time arguments:
//    N, (integere) number of input signals.
//
avg_pow(N, m) = si.bus(N) : par(i, N, pow(m)) :> / (N) : pow(1 / m);
// -----------------------------------------------------------------------------

// m2.avg_quad(N); -------------------------------------------------------------
//
// Quadratic mean.
//
// N inputs:
//    x1[n];
//    ...
//    xN-1[n];
//    xN[n].
//
// 1 outputs:
//    y[n], quadratic mean of the input signals.
//
// Compile-time arguments:
//    N, (integer) number of input signals.
//
avg_quad(N) = si.bus(N) : par(i, N, _ <: *) :> / (N) : sqrt;
// -----------------------------------------------------------------------------

// m2.bip(x[n]); ---------------------------------------------------------------
//
// Unipolar to bipolar signal conversion: [0; 1] range to [-1; 1] range.
//
// 1 inputs:
//    x[n].
//
// 1 outputs:
//    y[n], bipolarised input.
//
bip(x) = x * 2 - 1;
// -----------------------------------------------------------------------------

// m2.complement(x[n]); --------------------------------------------------------
//
// Complement.
//
// 1 inputs:
//    x[n].
//
// 1 outputs:
//    y[n], 1 - x[n].
//
complement(x) = 1 - x;
// -----------------------------------------------------------------------------

// m2.delta(S, dt[n], x[n]); ---------------------------------------------------
//
// First derivative using linear interpolation delay lines, hence
// allowing fractional differentiation periods.
//
// 2 inputs:
//    dt[n], differentiation period in seconds;
//    x[n].
//
// 1 outputs:
//    y[n], first derivative of x[n].
//
// Compile-time arguments:
//    S, maximum differentiation period in seconds.
//
delta(s, t, in) =  in - d2.del_lin(s, t, in);
// -----------------------------------------------------------------------------

// m2.delta2(S, dt[n], x[n]); ---------------------------------------------------
//
// Second derivative using linear interpolation delay lines, hence
// allowing fractional differentiation periods.
//
// 2 inputs:
//    dt[n], differentiation period in seconds;
//    x[n].
//
// 1 outputs:
//    y[n], second derivative of x[n].
//
// Compile-time arguments:
//    S, maximum differentiation period in seconds.
//
delta2(s, t, in) = delta(s, t, in) : delta(s, t);
// -----------------------------------------------------------------------------

// m2.diff(x[n]); --------------------------------------------------------------
//
// Differentiator: special case of a delta-function where the
// differentiation period is 1 / SR.
//
// 1 inputs:
//    x[n].
//
// 1 outputs:
//    y[n], first derivative of x[n].
//
diff(x) = x - x';
// -----------------------------------------------------------------------------

// m2.div(x1[n], x2[n]); -------------------------------------------------------
//
// Divider that avoids INF with division by zero, as it can sometimes
// cause crashes.
//
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] / x2[n], if x2[n] != 0.
//
div(x1, x2) = m2.if(x2 == 0, 0, x1 / x2);
// -----------------------------------------------------------------------------

// m2.hp_and(x1[n], x2[n]); ----------------------------------------------------
//
// Hyperbolic paraboloid AND.
// 
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n].
//
hp_and(x, y) = x * y;
// -----------------------------------------------------------------------------

// m2.hp_imp(x1[n], x2[n]); ----------------------------------------------------
//
// Hyperbolic paraboloid IMPLIES.
// 
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n].
//
hp_imp(x, y) = 1 - x + x * y;
// -----------------------------------------------------------------------------

// m2.hp_nand(x1[n], x2[n]); ---------------------------------------------------
//
// Hyperbolic paraboloid NOT AND.
// 
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n].
//
hp_nand(x, y) = 1 - x * y;
// -----------------------------------------------------------------------------

// m2.hp_nimp(x1[n], x2[n]); ---------------------------------------------------
//
// Hyperbolic paraboloid NOT IMPLIES.
// 
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n].
//
hp_nimp(x, y) = x * (1 - y);
// -----------------------------------------------------------------------------

// m2.hp_nor(x1[n], x2[n]); ----------------------------------------------------
//
// Hyperbolic paraboloid NOT OR.
// 
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n].
//
hp_nor(x, y) = 1 - x - y + x * y;
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// hyperbolic paraboloid NOT excluding OR
// m2.hp_nxr(x1[n], x2[n]); ----------------------------------------------------
//
// Hyperbolic paraboloid NOT excluding OR.
// 
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n].
//
hp_nxr(x, y) = 1 - x - y + 2 * x * y;
// -----------------------------------------------------------------------------

// m2.hp_or(x1[n], x2[n]); -----------------------------------------------------
//
// Hyperbolic paraboloid OR.
// 
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n].
//
hp_or(x, y) = x + y - x * y;
// -----------------------------------------------------------------------------

// m2.hp_xor(x1[n], x2[n]); ----------------------------------------------------
//
// Hyperbolic paraboloid excluding OR.
// 
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n].
//
hp_xor(x, y) = x + y - 2 * x * y;
// -----------------------------------------------------------------------------

// m2.interpolate_mn(M, N, I[n]); ----------------------------------------------
//
// Linear interpolation to circularly transition between between M blocks of 
// N signals ("spat" by Romain Michon). The function shifts through the
// M blocks based on an index in the range [0; 1], representing the
// beginning and end of an interpolation cycle. For example, if we have four
// blocks, the index from 0 to .25 is the transition between block one and
// two, .25 to .5 is the transition between two and three, .5 to .75 is the
// transition between three and four, and .75 to 1 is the transition
// between four and one.
//
// M*N+1 inputs:
//    I[n], interpolation index in the [0; 1] range performing a
//         complete interpolation cycle among the M blocks. 
//    x11[n];
//    ...
//    x1N-1[n];
//    x1N[n];
//    ...
//    xM-11[n];
//    ...
//    xM-1N-1[n];
//    xM-1N[n];
//    ...
//    xMN[n].
//
// N outputs:
//    y1[n];
//    ...
//    yN-1[n];
//    yN[n], interpolated N-signal block.
//
// Compile-time arguments:
//    M, (integer) number of blocks;
//    N, integer number of signals in each block.
//
interpolate_mn(m, n, index) =  spat(m, index, 1) , 
                               ro.interleave(n, m) : 
      ro.interleave(m, n + 1) :    par(i, m, (_ <: si.bus(n)) , 
                                   si.bus(n) : ro.interleave(n, 2) : 
           par(i, n, *)) :> si.bus(n)
      with {
           spat(n, a, d) = par(i, n, (scaler(i, n, a, d) ))
               with {
                   scaler(i, n, a, d) = (d / 2.0 + .5) * max(.0, 1.0 - 
                       abs(fmod(a + .5 + float(n - i) / n, 1.0) - .5) * n * d);
               };
      };
// -----------------------------------------------------------------------------

// m2.if(C[n], T[n], E[n]); ----------------------------------------------------
//
// If-then-else – unlike Faust's if-then-else, the condition is true for
// any value != than 0, whereas Faust gives false for |fractions| < 1.
//
// 3 inputs:
//    C[n], condition;
//    T[n], "then" signal;
//    E[n], "else" signal.
//
// 1 outputs:
//    y[n], which is either T[n] or E[n] depending on C[n].
//
if(cond, then, else) = cond != 0 , 
                       else , 
                       then : select2;
// -----------------------------------------------------------------------------

// m2.ifN((C1[n], T1[n], ..., CN-1[n], TN-1[n], CN[n], TN[n], E[n])); ----------
//
// If-then-else-if-... with arbitrary number of conditions. 
// It takes pairs of IF-THEN couples plus a final ELSE. 
// These should be given as a list, hence within parentheses.
// Note that it only works if outputting single values for each
// condition due to Faust's limitations in list processing.
// Code by Oleg Nesterov.
//
// N*2+1 inputs:
//    C1[n]; 
//    T1[n]; 
//    ...; 
//    CN-1[n]; 
//    TN-1[n]; 
//    CN[n]; 
//    TN[n]; 
//    E[n].    (Note that the number of inputs depends on the specific
//             functions of each statement.)
//
// 1 outputs:
//    y[n], one of the T-signals or the E-signal.
//
ifN((c, t, e)) = m2.if(c, t, ifN(e));
ifN(e) = e;
// -----------------------------------------------------------------------------

// m2.inv(x[n]); ---------------------------------------------------------------
//
// INF-safe inverse.
//
// 1 inputs:
//    x[n].
//
// 1 outputs:
//    1 / x[n].
//
inv(x) = div(1, x);
// -----------------------------------------------------------------------------

// m2.line(S[n]); --------------------------------------------------------------
//
// Line function. Note that the function does not start from 0. If you
// require a precise behaviour, you can use the following:
//    m2.line(ba.select2(1', 0, A[n]));
//
// 1 inputs:
//    S[n], the slope of the line (y/x ratio).
//
// 1 outputs:
//    y[n], the line function.
//
line(s) = select2(1', 0, s) / ma.SR :  +
                                       ~ _;
// -----------------------------------------------------------------------------

// m2.line_reset(S[n], reset[n]); ----------------------------------------------
//
// Line function with reset input. Note that the function does not start 
// from 0 until it is reset. If you require a precise behaviour from the very 
// beginning, you can use the following:
//    m2.line_reset(ba.select2(1', 0, S[n]), reset[n]);
//
// 1 inputs:
//    S[n], the slope of the line (y/x ratio);
//    reset[n], it resets the line to 0 if its value is non-zero.
//
// 1 outputs:
//    y[n], the line function.
//
line_reset(rate, reset) =  rate / ma.SR * r :  +
                                               ~ * (r)
      with {
           r = 1 - (reset != 0);
      };
// -----------------------------------------------------------------------------

// m2.map_lin(L[n], H[n], x[n]); -----------------------------------------------
//
// Linear mapping of an input signal in the range [0; 1] on to an arbitrary
// range determined by signals.
//
// 3 inputs:
//    L[n], lower edge of the range;
//    H[n], upper edge of the range;
//    x[n], input [0; 1].
//
// 1 outputs:
//    y[n], mapped x[n].
//
map_lin(lower, upper, x) = x * (upper - lower) + lower;
// -----------------------------------------------------------------------------

// m2.map_par(T[n], V[n], S[n], x[n]); -----------------------------------------
//
// Parabolic mapping of an input signal in the range [0; 1] on to a
// parabola whose curvature, vertex, and sides are determined by signals.
//
// 4 inputs:
//    T[n], tension parameter (curvature), the exponent, which is
//             constrained to be an even integer;
//    V[n], vertex of the parabola;
//    S[n], value of the sides of the parabola at the minimum and
//             maximum values of the input signal (0 and 1).
//    x[n], input [0; 1].
//
// 1 outputs:
//    y[n], mapped x[n].
//
map_par(t, vertex, sides, x) = x * 2 - 1 : pow(t_1) : map_lin(vertex, sides)
      with {
           t_1 = int(t) * 2;
      };
// -----------------------------------------------------------------------------

// m2.map_pcw(S[n], E1[n], L1[n], H1[n], E2[n], L2[n], H2[n], x[n]); -----------
//
// Piece-wise mapping of an input signal in the range [0; 1] on to two
// segments with independent curves and ranges determined by signals.
//
// 8 inputs:
//    S[n], split-point up until the characteristics of the first
//             segment apply, where as those from the second segment
//             apply if the signal is above it;
//    E1[n], exponent for the first segment;
//    L1[n], lower edge of the first segment;
//    H1[n], upper edge of the first segment;
//    E2[n], exponent of the second segment;
//    L2[n], lower edge of the second segment;
//    H2[n], upper edge of the second segment;
//    x[n], input in the range [0; 1].
//
// 1 outputs:
//    y[n], mapped x[n].
//
map_pcw(split, exp1, l1, u1, exp2, l2, u2, x) = 
      m2.if(x <= split, map_pow(exp1, l1, u1, x), map_pow(exp2, l2, u2, x));
// -----------------------------------------------------------------------------

// m2.map_log(T[n], L[n], H[n], x[n]); -----------------------------------------
//
// Mapping of an input signal in the range [0; 1] on to a logarithmic
// curve with arbitrary ranges and curvature determined by signals.
//
// 4 inputs:
//    T[n], `tension` parameter – curvature of the log function;
//    L[n], lower edge of the function;
//    H[n], upper edge of the function;
//    x[n], input in the range [0; 1].
//
// 1 outputs:
//    y[n], mapped x[n].
//
map_log(t, lower, upper, x) = log(x * (t - 1) + 1) / log(t) : 
      map_lin(lower, upper);
// -----------------------------------------------------------------------------

// m2.map_pow(T[n], L[n], H[n], x[n]); -----------------------------------------
//
// Mapping of an input signal in the range [0; 1] on to a power curve
// with arbitrary curvature and ranges determined by signals.
//
// 4 inputs:
//    T[n], `tension` parameter – curvature of the power function;
//    L[n], lower edge of the function;
//    H[n], upper edge of the function;
//    x[n], input in the range [0; 1].
//
// 1 outputs:
//    y[n], mapped x[n].
//
map_pow(t, lower, upper, x) = x : pow(t) : map_lin(lower, upper);
// -----------------------------------------------------------------------------

// m2.matrix(R, C); ------------------------------------------------------------
//
// R-input, C-output matrix:
//
// a11 a12 … a1C
// a21 a22 … a2C
//  ⋮   ⋮  ⋱  ⋮
// aR1 aR2 … aRC
// 
// R+R*C inputs:
//    R, input signals to be distributed through the C outputs;
//    R*C, coefficients as shown in the diagram above;
//
// C outputs.
//
// Compile-time arguments:
//    R, (integer) number of rows;
//    C, (integer) number columns.
//
matrix(r, c) = (si.bus(r), ro.interleave(c, r)) : ro.interleave(r, c + 1) :
      par(i, r, (_ <: si.bus(c)) , 
      si.bus(c) : ro.interleave(c, 2) : par(i, c, *)) :> si.bus(c);
// -----------------------------------------------------------------------------

// m2.maxN(N); -----------------------------------------------------------------
//
// It returns the max value between a specified number of input signals.
//
// N inputs.
//
// 1 outputs:
//    y[n], max value between the N signals.
//
// Compile-time arguments:
//    N, (integer) number of input signals.
//
maxN(1) = _;
maxN(2) = max;
maxN(N) = max(maxN(N - 1));
// -----------------------------------------------------------------------------

// m2.minN(N); -----------------------------------------------------------------
//
// It returns the min value between a specified number of input signals.
//
// N inputs.
//
// 1 outputs:
//    y[n], min value between the N signals.
//
// Compile-time arguments:
//    N, (integer) number of input signals.
//
minN(1) = _;
minN(2) = min;
minN(N) = min(minN(N - 1));
// -----------------------------------------------------------------------------

// m2.ny; ----------------------------------------------------------------------
//
// Nyquist or half the samplerate.
//
// 0 inputs.
//
// 1 outputs:
//    y[n], SR/2.
//
ny = ma.SR / 2;
// -----------------------------------------------------------------------------

// m2.ph(F[n], reset[n]); ------------------------------------------------------
//
// Phasor with phase reset.
//
// 2 inputs:
//    F[n], frequency in Hz;
//    reset[n], it resets the phasor to 0 for values different than 0.
//
// 1 outputs:
//    y[n], phasor oscillator.
//
ph(freq, reset) = freq / ma.SR * r :   (+ : ma.decimal) 
                                       ~ * (r)
      with {
           r = 1 - (reset != 0);
      };
// -----------------------------------------------------------------------------

// m2.primes; ------------------------------------------------------------------
//
// First 64 prime numbers.
//
// 0 inputs.
//
// 64 outputs:
//    2;
//    3;
//    5;
//    ...;
//    311.
//
primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,
67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149,
151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311);
// -----------------------------------------------------------------------------

// m2.prime_base_pow(N, E[n]); -------------------------------------------------
//
// N-th prime number raised to a power.
//
// 1 inputs:
//    E[n], exponent.
//
// 1 outputs:
//    y[n], N-th prime number raised to a power.
//
// Compile-time arguments:
//    N, (integer) N-th prime number up to 64.
//
prime_base_pow(N, exponent) =  ba.take(N, primes) ,
                               exponent : pow;
// -----------------------------------------------------------------------------

// m2.relay_hysteron(A[n], B[n], x[n]); ----------------------------------------
//
// Relay hysteron – the basic building block of the Preisach model.
//
// 3 inputs:
//    A[n], lower edge;
//    B[n], upper edge;
//    x[n].
//
// 1 outputs:
//    y[n], relay output, 0 or 1 (non-active or active).
//
relay_hysteron(alpha, beta, x) =   loop 
                                   ~ _
with {
    loop(fb) = m2.if(x <= alpha, 0, m2.if(x >= beta, 1, fb));
};
// -----------------------------------------------------------------------------

// m2.round_pow2(x[n]); --------------------------------------------------------
//
// Closest power-of-two to the input signal.
//
// 1 inputs:
//    x[n].
//
// 1 outputs:
//    y[n], closest power-of-two to x[n].
//
round_pow2(x) = 2 ^ (rint(ma.log2(x)));
// -----------------------------------------------------------------------------

// m2.rt9(T[n]); ---------------------------------------------------------------
//
// One-pole coefficient for ~9 dB exponential decay (e^-1 factor) in a desired
// time specified in seconds.
//
// 1 inputs:
//    T[n], decay time in seconds.
//
// 1 outputs:
//    y[n], pole position.
//
rt9(t) = ba.tau2pole(t);
// -----------------------------------------------------------------------------

// m2.rt19(T[n]); --------------------------------------------------------------
//
// One-pole coefficient for ~19 dB exponential decay (e^-2.2 factor factor) 
// in a desired time specified in seconds. This decay factor is used in 
// [Zölzer 2008] for the calculation of RMS with 1-pole filters.
//
// 1 inputs:
//    T[n], decay time in seconds.
//
// 1 outputs:
//    y[n], pole position.
//
rt19(t) = ba.tau2pole(t / 2.2);
// -----------------------------------------------------------------------------

// m2.rt55(T[n]); --------------------------------------------------------------
//
// One-pole coefficient for ~55 dB exponential decay (e^(-2pi) factor) in a 
// desired time specified in seconds.
// This coefficient calculation is found in [Chamberlin 1985] for the
// implementation of one-pole lowpass filters that simulate the dis/charging
// behaviours of a capacitor.
//
// 1 inputs:
//    T[n], decay time in seconds.
//
// 1 outputs:
//    y[n], pole position.
//
rt55(t) = ba.tau2pole(t / (2 * ma.PI));
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// 1-pole coeff. for ~60 dB decay (e^-log(1000) factor) in a desired time "t".
// m2.rt60(T[n]); --------------------------------------------------------------
//
// One-pole coefficient for ~60 dB exponential decay (e^-log(1000) factor) in a 
// desired time specified in seconds.
// This coefficient calculation is commonly seen in the design of
// artificial reverberation.
//
// 1 inputs:
//    T[n], decay time in seconds.
//
// 1 outputs:
//    y[n], pole position.
//
rt60(t) = ba.tau2pole(t / 6.907755279);
// -----------------------------------------------------------------------------

// m2.sd(N); -------------------------------------------------------------------
//
// Stanrdard deviation.
//
// N inputs.
//
// 1 outputs:
//    y[n], standard deviation between the N input signals.
//
// Compile-time arguments:
//    N, input signals.
//
sd(N) = sqrt(var(N));
// -----------------------------------------------------------------------------

// m2.sp; ----------------------------------------------------------------------
//
// Sampling period.
//
// 0 inputs.
//
// 1 outputs:
//    y[n], sampling period, 1 / SR.
//
sp = 1 / ma.SR;
// -----------------------------------------------------------------------------

// m2.topologies(R, C, I[n]); --------------------------------------------------
//
// Linear interpolation to circularly shift through matrix topologies
// according to an index in the range [0; 1]. There are four topologies
// with arbitrary rows and columns: full, anti-diagonal, diagonal, and
// right-shifted diagonal. The ranges to transition among the four topologies
// are 0 to .25 to shift from the first to the second topology, .25 to
// .5 from the second to the third, .5 to .75 from the third to the fourth,
// and .75 to 1 from the fourth and back to the first one.
//
// The output of this function can be used as the coefficients for an
// m2.matrix function that has the same number of rows and columns.
//
// 1 inputs:
//    I[n], interpolation index in the range [0; 1].
//
// R*C outputs:
//    y11 y12 … y1C
//    y21 y22 … y2C
//    ⋮   ⋮  ⋱  ⋮
//    yR1 yR2 … yRC
// 
// Compile-time arguments:
//    R, (integer) number of rows;
//    C, (integer) number columns.
// 
topologies(r, c, type) =   top_full(r, c) ,
                           top_anti_diag(r, c) ,
                           top_diagonal(r, c) ,
                           top_diag_shift(r, c, 1) : 
      interpolate_mn(4, r * c, type);
// -----------------------------------------------------------------------------

// m2.top_anti_diag(R, C); -----------------------------------------------------
//
// Anti-diagonal matrix topology.
//
// Example for a 4x4 matrix:
//
//    0 1 1 1
//    1 0 1 1
//    1 1 0 1
//    1 1 1 0
//
// 0 inputs.
//
// R*C outputs:
//    y11 y12 … y1C
//    y21 y22 … y2C
//    ⋮   ⋮  ⋱  ⋮
//    yR1 yR2 … yRC
//
// Compile-time arguments:
//    R, (integer) number of rows;
//    C, (integer) number columns.
// 
top_anti_diag(r, c) = par(i, r, par(j, c, (j % r) != (i % c)));
// -----------------------------------------------------------------------------

// m2.top_diagonal(R, C); ------------------------------------------------------
//
// Diagonal matrix topology.
//
// Example for a 4x4 matrix:
//
//    1 0 0 0
//    0 1 0 0
//    0 0 1 0
//    0 0 0 1
//
// 0 inputs.
//
// R*C outputs:
//    y11 y12 … y1C
//    y21 y22 … y2C
//    ⋮   ⋮  ⋱  ⋮
//    yR1 yR2 … yRC
//
// Compile-time arguments:
//    R, (integer) number of rows;
//    C, (integer) number columns.
//
top_diagonal(r, c) = par(i, r, par(j, c, (j % r) == (i % c)));
// -----------------------------------------------------------------------------

// m2.top_diag_shift(R, C, S[n]); ----------------------------------------------
//
// Shifted diagonal matrix topology.
//
// Example for a 4x4 matrix and a one-position-shift:
//
//    0 1 0 0
//    0 0 1 0
//    0 0 0 1
//    1 0 0 0
//
// 1 inputs:
//    S[n], cast to integer, it determines the shift amount.
//
// R*C outputs:
//    y11 y12 … y1C
//    y21 y22 … y2C
//    ⋮   ⋮  ⋱  ⋮
//    yR1 yR2 … yRC
//
// Compile-time arguments:
//    R, (integer) number of rows;
//    C, (integer) number columns.
//
top_diag_shift(r, c, s) = 
      par(i, r, par(j, c, (j  % r) == ((i + int(s)) % c)));
// -----------------------------------------------------------------------------

// m2.top_full(R, C); ----------------------------------------------------------
//
// Fully-connected matrix topology. Essentially, the function outputs as
// many 1s in parallel as the product between the specified rows and columns.
//
// Example for a 4x4 matrix:
//
//    1 1 1 1
//    1 1 1 1
//    1 1 1 1
//    1 1 1 1
//
// 0 inputs.
//
// R*C outputs:
//    y11 y12 … y1C
//    y21 y22 … y2C
//    ⋮   ⋮  ⋱  ⋮
//    yR1 yR2 … yRC
//
// Compile-time arguments:
//    R, (integer) number of rows;
//    C, (integer) number columns.
//
top_full(r, c) = 1 <: si.bus(r * c);
// -----------------------------------------------------------------------------

// m2.top_tri_low(R, C); -------------------------------------------------------
//
// Lower-triangle matrix topology.
//
// Example for a 4x4 matrix:
//
//    1 0 0 0
//    1 1 0 0
//    1 1 1 0
//    1 1 1 1
//
// 0 inputs.
//
// R*C outputs:
//    y11 y12 … y1C
//    y21 y22 … y2C
//    ⋮   ⋮  ⋱  ⋮
//    yR1 yR2 … yRC
//
// Compile-time arguments:
//    R, (integer) number of rows;
//    C, (integer) number columns.
//
top_tri_low(r, c) = par(i, r, par(j, c, (j % r) <= (i % c)));
// -----------------------------------------------------------------------------

// m2.top_tri_up(R, C); -----000------------------------------------------------
//
// Upper-triangle matrix topology.
//
// Example for a 4x4 matrix:
//
//    1 1 1 1
//    0 1 1 1
//    0 0 1 1
//    0 0 0 1
//
// 0 inputs.
//
// R*C outputs:
//    y11 y12 … y1C
//    y21 y22 … y2C
//    ⋮   ⋮  ⋱  ⋮
//    yR1 yR2 … yRC
//
// Compile-time arguments:
//    R, (integer) number of rows;
//    C, (integer) number columns.
//
top_tri_up(r, c) = par(i, r, par(j, c, (j % r) >= (i % c)));
// -----------------------------------------------------------------------------

// m2.uni(x[n]); ---------------------------------------------------------------
//
// Function to convert a bipolar signal to unipolar, assuming an input
// in the range [-1; 1].
//
// 1 inputs:
//    x[n], input signal assumed in the range [-1; 1].
//
// 1 outputs:
//    y[n], output in the range [0; 1].
//
uni(x) = (x + 1) / 2;
// -----------------------------------------------------------------------------

// m2.unit_log(T[n], x[n]); ----------------------------------------------------
//
// Logarithmic mapping of an input signal in the range [0; 1] into an
// output in the same range and arbitrary curvature (tension factor).
//
// 2 inputs:
//    T[n], curvature, tensione factor;
//    x[n], input in the range [0; 1].
//
// 1 outputs:
//    y[n], logarithmically-mapped x[n] in the range [0; 1].
//
unit_log(t, x) = log(x * (t - 1) + 1) / log(t);
// -----------------------------------------------------------------------------

// m2.var(N); ------------------------------------------------------------------
//
// Variance of a set of N elements.
//
// N inputs.
//
// 1 outputs:
//    y[n], variance of the N input signals.
//
// Compile-time arguments:
//    N, (integer) number of input signals.
//
var(N) = si.bus(N) <:  si.bus(N) ,
                       (si.bus(N) :> / (N) <: si.bus(N)) :
      ro.interleave(N, 2) : par(i, N, - <: *) :> / (N);
// -----------------------------------------------------------------------------

// m2.w(F[n]); -----------------------------------------------------------------
//
// Angular frequency.
//
// 1 inputs:
//    F[n], frequency in Hz.
//
// 1 outputs:
//    y[n], angular frequency between 0 and π, assuming an input between
//             0 and Nyquist.
//
w(x) = x * 2 * ma.PI / ma.SR;
// -----------------------------------------------------------------------------

// m2.window_hann(ph[n]); -------------------------------------------------------
//
// Hann window.
//
// 1 inputs:
//    ph[n], phase of the function where a full cycle is in the range [0; 1].
//
// 1 outputs:
//    y[n], Hann function.
//
window_hann(x) = sin(ma.PI * x) <: *;
// -----------------------------------------------------------------------------

// m2.window_sine(ph[n]); ------------------------------------------------------
//
// Sine window.
//
// 1 inputs:
//    ph[n], phase of the function where a full cycle is in the range [0; 1].
//
// 1 outputs:
//    y[n], Sine function.
//
window_sine(x) = sin(ma.PI * x);
// -----------------------------------------------------------------------------

// m2.wrap(L[n], H[n], x[n]); --------------------------------------------------
//
// Wrapping function.
//
// 3 inputs:
//    L[n], lower edge;
//    H[n], upper edge;
//    x[n].
//
// 1 outputs:
//    y[n], wrapped-up x[n].
//
wrap(lower, upper, x) = 
      (x - lower) / (upper - lower) : ma.decimal * (upper - lower) + lower;
// -----------------------------------------------------------------------------

// m2.y_and(x1[n], x2[n]); -----------------------------------------------------
//
// Yager AND.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] AND x2[n].
//
y_and(x, y) = 1 - min(1, sqrt((1 - x) ^ 2 + (1 - y) ^ 2));
// -----------------------------------------------------------------------------

// m2.y_or(x1[n], x2[n]); ------------------------------------------------------
//
// Yager OR.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] OR x2[n].
//
y_or(x, y) = min(1, (x ^ 2 + y ^ 2) ^ 2);
// -----------------------------------------------------------------------------

// m2.z_and(x1[n], x2[n]); -----------------------------------------------------
//
// Zadeh AND.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] AND x2[n].
//
z_and(x, y) = min(x, y);
// -----------------------------------------------------------------------------

// m2.z_imp(x1[n], x2[n]); -----------------------------------------------------
//
// Zadeh IMPLIES.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] IMPLIES x2[n].
//
z_imp(x, y) = 1 - min(x, 1 - y);
// -----------------------------------------------------------------------------

// m2.z_nand(x1[n], x2[n]); ----------------------------------------------------
//
// Zadeh NOT AND.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] NAND x2[n].
//
z_nand(x, y) = 1 - min(x, y);
// -----------------------------------------------------------------------------

// m2.z_nimp(x1[n], x2[n]); ----------------------------------------------------
//
// Zadeh NOT IMPLIES.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] NOT IMPLIES x2[n].
//
z_nimp(x, y) = min(x, 1 - y);
// -----------------------------------------------------------------------------

// m2.z_nor(x1[n], x2[n]); -----------------------------------------------------
//
// Zadeh NOT OR.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] NOR x2[n].
//
z_nor(x, y) = 1 - max(x, y);
// -----------------------------------------------------------------------------

// m2.z_nxr(x1[n], x2[n]); -----------------------------------------------------
//
// Zadeh NOT XOR.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] NXR x2[n].
//
z_nxr(x, y) = 1 - x - y + 2 * min(x, y);
// -----------------------------------------------------------------------------

// m2.z_or(x1[n], x2[n]); ------------------------------------------------------
//
// Zadeh OR.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] OR x2[n].
//
z_or(x, y) = max(x, y);
// -----------------------------------------------------------------------------

// m2.z_xor(x1[n], x2[n]); -----------------------------------------------------
//
// Zadeh XOR.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] XOR x2[n].
//
z_xor(x, y) = x + Y - 2 * min(x, y);
// -----------------------------------------------------------------------------
