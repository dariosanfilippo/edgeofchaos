// MORE MATH

ba = library("basics.lib");
de = library("delays.lib");
d2 = library("delays2.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");

primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,
67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149,
151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311);

// Nyquist
ny = ma.SR/2;

// sampling period
speriod = 1/ma.SR;

// NAN-safe divider
div(x1, x2) = ba.if(x2 : ==(0), 0, (x1 ,
                                        x2 : /));

// closest power of 2
round_pow2(x) = 2^(ma.log2(x) : rint);

// wrap around a range
wrap(x, lower, upper) = (x-lower)/(upper-lower) : ma.decimal : *(upper-lower) : +(lower);

// angular frequency
w(x) = x*2*ma.PI/ma.SR;

// 60-dB decay in a desired time
rt60(x) =   .001 ,
            (   speriod ,
                max(x, .001) : /) : pow;

// n-th prime number raised to a power
prime_base_pow(n) = ba.take(n, primes) ,
                    _ : pow;

// line: in signal sets x/y ratio
line =  _ ,
        ma.SR : / : +
                    ~ _;

// line with reset input
line_reset(rate, reset) =  rate ,
                           ma.SR : / : +
                                       ~ *(1-(reset : !=(0)));

// phasor with phase reset
ph(freq, reset) = freq/ma.SR : (+ : ma.decimal) ~ *(1-(reset : !=(0)));

// complement
com(x) = 1-x;

// differentiator
diff(x) = x-x';

// first derivative
delta(in, t) =  in ,
                d2.del_lin(in, t, 16) : -;

// second derivative
delta2(in, t) = delta(in, t) : delta(in, t);

// linear mapping
map_lin(x, lower, upper) = x*(upper-lower)+lower;

// power mapping; t is the exponent or tension parameter
map_pow(x, t, lower, upper) = x : pow(t) : map_lin(_, lower, upper);

// logarithmic mapping; t is the base acting as a tension parameter
map_log(x, t, lower, upper) = log(x*(t-1)+1)/log(t) : map_lin(_,
lower, upper);

// parabolic mapping; t (must be an even int) is a tension parameter
map_par(x, t, lower, upper) = x*2-1 : pow(t_1) : map_lin(_,
lower, upper)
with {
      t_1 = t : int : *(2);
};

// piece-wise mapping (two segments)
map_pcw(x, split, exp1, exp2, l1, u1, l2, u2) = ba.if( x : <=(split),
                                                       map_pow(x, exp1, l1, u1),
                                                       map_pow(x, exp2, l2, u2));

// Hann window
window_hann(x) = sin(ma.PI*x) <: *;

// Sine window
window_sine(x) = sin(ma.PI*x);
