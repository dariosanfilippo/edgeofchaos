// =============================================================================
// ========== maths2.lib =======================================================
// =============================================================================
// 
// Math library containing functions for statistics, linear and nonlinear
// fuzzy logic, interpolators, network topologies, matrixes, linear and
// nonlinear mapping, windowing functions, hysteresis, angular frequency,
// and several time constants for exponential decays in one-pole systems.
// 
// The environment prefix is "m2".
// 
// List of functions:
// 
//    aad, 
//    asinc_bi,
//    asinc_uni,
//    avg_ari, 
//    avg_ari_w, 
//    avg_geo, 
//    avg_geo_w, 
//    avg_harm, 
//    avg_harm_w, 
//    avg_pow, 
//    avg_quad,
//    bip, 
//    complement,
//    dec2bin,
//    delta, 
//    delta2, 
//    diff, 
//    div,
//    factorial,
//    hp_and, 
//    hp_imp, 
//    hp_nand, 
//    hp_nimp, 
//    hp_nor, 
//    hp_nxr, 
//    hp_or, 
//    hp_xor, 
//    interpolate_mn, 
//    if, 
//    ifN, 
//    inv, 
//    line, 
//    line_reset, 
//    map_lin, 
//    map_par, 
//    map_pcw, 
//    map_log, 
//    map_pow, 
//    matrix, 
//    maxN, 
//    minN, 
//    ny, 
//    ph, 
//    primes, 
//    prime_base_pow, 
//    relay_hysteron, 
//    round_pow2, 
//    rt9, 
//    rt19, 
//    rt55, 
//    rt60,
//    seq_catalan,
//    seq_fibonacci,
//    seq_hexagonal,
//    seq_lazy_caterer,
//    seq_magic_number,
//    seq_pentagonal,
//    seq_square,
//    seq_triangular
//    sd, 
//    sp, 
//    topologies, 
//    top_anti_diag, 
//    top_diagonal, 
//    top_diag_shift, 
//    top_full, 
//    top_tri_low, 
//    top_tri_up,
//    twopi
//    uni, 
//    unit_log, 
//    var, 
//    w, 
//    window_hann, 
//    window_sine, 
//    wrap, 
//    y_and, 
//    y_or,
//    zeropad_up,
//    zeropad_down,
//    z_and, 
//    z_imp, 
//    z_nand, 
//    z_nimp, 
//    z_nor, 
//    z_nxr, 
//    z_or, 
//    z_xor.
//
// Copyright (c) 2019-2020, Dario Sanfilippo <sanfilippo.dario at gmail dot com>
// All rights reserved.

declare name "Math Library";
declare author "Dario Sanfilippo";
declare copyright "Copyright (c) 2019-2020, Dario Sanfilippo <sanfilippo.dario
      at gmail dot com>";
declare version "1.0.0";
declare license "GPLv2.0";

ba = library("basics.lib");
de = library("delays.lib");
d2 = library("delays2.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
ro = library("routes.lib");
si = library("signals.lib");

// m2.aad(N); ------------------------------------------------------------------
//
// Normalised average absolute deviation around the mean.
//
// N inputs:
//    x1[n];
//    ...
//    xN-1[n];
//    xN[n].
//
// 1 outputs:
//    y[n], average absolute deviation in the range [0; 1] of the input signals.
//
// 1 compile-time arguments:
//    N, (integer) number of input signals.
//
aad(N) = si.bus(N) <:  (si.bus(N) ,
                       (si.bus(N) :> / (N) <: si.bus(N)) : ro.interleave(N, 2) : 
      par(i, N, (- : abs)) :> _) ,
      (si.bus(N) :> / (N)) : m2.div : / ((N - 1) * 2);
// -----------------------------------------------------------------------------

// m2.asinc_bi(H[n], ph[n]); ---------------------------------------------------
//
// asinc_bp[n] = sin(2H[n]2π*ph[n])/(sin(2π*ph[n])*2H[n]).
//
// Bipolar periodic sinc function with arbitrary number of harmonics for
// the generation of band-limited impulse trains (BLIT).
// The bipolar BLIT has no DC component and the number of harmonics include the 
// fundamental frequency and its odd multiples. 
//
// The amplitude of the function, regardless of the harmonics, is normalised to 
// unit-amplitude peaks.
//
// The bipolar sinc has a period of 2π, although the phase input of the
// function is normalised to the range [0; 1] for a full cycle.
//
// Unlike the technique described in [Stilson and Smith 1996], the
// bipolar sinc function is realised by having an even ratio between the
// frequencies of the sine functions, which results in a precise harmonic
// content throughout the entire frequency range when deployed in BLITs.
//
// 2 inputs:
//    H[n], (integer) number of harmonics including the fundamental
//         frequency and the odd harmonics.
//    ph[n], phase of the sinc function in the range [0; 1]. Values
//         outside of that range are allowed as they are wrapped around.
//
// 1 outputs:
//    y[n], bipolar sinc function.
//
asinc_bi(M, x) = m2.if(phase < ma.EPSILON,
                       1,
                       m2.if(  abs(.5 - phase) < ma.EPSILON,
                               -1,
                               sin(M1 * m2.twopi * phase) / 
                                   (sin(m2.twopi * phase) * M1)))
      with {
           M1 = rint(M) * 2;
           phase = ma.frac(x);
      };
// -----------------------------------------------------------------------------

// m2.asinc_uni(H[n], ph[n]); --------------------------------------------------
//
// asinc_uni[n] = sin((2H[n]+1)*2π*ph[n])/(sin(2π*ph[n])*(2H[n]+1)).
//
// Unipolar periodic sinc function with arbitrary number of harmonics
// for the generation of unipolar band-limited impulse trains.
// The unipolar BLIT has a DC component and the number of harmonics include the 
// fundamental frequency and its multiples (both even and odd). 
//
// The amplitude of the function, regardless of the harmonics, 
// is normalised to unit-amplitude peaks.
//
// The technique described here is based on the paper
// [Stilson and Smith 1996]:
//
// https://ccrma.stanford.edu/~stilti/papers/blit.pdf.
//
// The unipolar sinc has a period of π, although the phase input of the
// function is normalised to the range [0; 1] for a full cycle.
//
// 2 inputs:
//    H[n], (integer) number of harmonics including the fundamental
//         frequency and both even and odd multiples.
//    ph[n], phase of the sinc function in the range [0; 1]. Values
//         outside of that range are allowed as they are wrapped around.
//
// 1 outputs:
//    y[n], unipolar sinc function.
//
asinc_uni(M, x) = m2.if(phase < ma.EPSILON, 
                        1, 
                        sin(M1 * ma.PI * phase) / 
                           (sin(ma.PI * phase) * M1))
    with {
       M1 = rint(M) * 2 + 1;
       phase = ma.frac(x);
    };
// -----------------------------------------------------------------------------

// m2.avg_ari(N); --------------------------------------------------------------
//
// Arithmetic mean.
//
// N inputs:
//    x1[n];
//    ...
//    xN-1[n];
//    xN[n].
//
// 1 outputs:
//    y[n], arithmetic mean of the input signals.
//
// 1 compile-time arguments:
//    N, (integer) number of input signals.
//
avg_ari(N) = si.bus(N) :> / (N);
// -----------------------------------------------------------------------------

// m2.avg_ari_w(N); ------------------------------------------------------------
//
// Weighted arithmetic mean.
//
// 2N inputs:
//    x1[n];
//    ...
//    xN-1[n];
//    xN[n], input signals;
//    w1[n];
//    ...
//    wN-1[n];
//    wN[n], corresponding weighting signals.
//
// 1 outputs:
//    y[n], weighted arithmetic mean of the input signals.
//
// 1 compile-time arguments:
//    N, (integer) number of input signals and corresponding weighting
//         signals.
//
avg_ari_w(N) = si.bus(N) ,
               (si.bus(N) <:   si.bus(N) ,
                               (si.bus(N) :> _)) : 
      ro.interleave(N, 2) , 
      _ :  (par(i, N, *) :> _) / _;
// -----------------------------------------------------------------------------

// m2.avg_geo(N); --------------------------------------------------------------
//
// Geometric mean.
//
// N inputs:
//    x1[n];
//    ...
//    xN-1[n];
//    xN[n].
//
// 1 outputs:
//    y[n], geometric mean of the input signals.
//
// 1 compile-time arguments:
//    N, (integer) number of input signals.
//
avg_geo(N) = prod(i, N, _) : pow(1 / N);
// -----------------------------------------------------------------------------

// m2.avg_geo_w(N); ------------------------------------------------------------
//
// Weighted geometric mean.
//
// 2N inputs:
//    x1[n];
//    ...
//    xN-1[n]; 
//    xN[n], input signals;
//    w1[n];
//    ...
//    wN-1[n];
//    wN[n], corresponding weighting signals.
//
// 1 outputs:
//    y[n], weighted geometric mean of the input signals.
//
// 1 compile-time arguments:
//    N, (integer) number of input signals and corresponding weighting
//         signals.
//
avg_geo_w(N) = (si.bus(N) : par(i, N, log)) ,
               (si.bus(N) <:   si.bus(N) ,
                               (si.bus(N) :> _)) : 
      ro.interleave(N, 2) ,
      _ :  (par(i, N, *) :> _) / _ : exp;
// -----------------------------------------------------------------------------

// m2.avg_harm(N); -------------------------------------------------------------
//
// Harmonic mean.
//
// N inputs:
//    x1[n];
//    ...
//    xN-1[n];
//    xN[n].
//
// 1 outputs:
//    y[n], harmonic mean of the input signals.
//
// 1 compile-time arguments:
//    N, (integer) number of input signals.
//
avg_harm(N) = si.bus(N) : par(i, N, ma.inv) :> N / _;

// m2.avg_harm_w(N); -----------------------------------------------------------
//
// Weighted harmonic mean.
//
// 2N inputs:
//    x1[n];
//    ...
//    xN-1[n]; 
//    xN[n], input signals;
//    w1[n];
//    ...
//    wN-1[n];
//    wN[n], corresponding weighting signals.
//
// 1 outputs:
//    y[n], weighted harmonic mean of the input signals.
//
// 1 compile-time arguments:
//    N, (integer) number of input signals and corresponding weighting
//         signals.
//
avg_harm_w(N) =    (si.bus(N) : par(i, N, ma.inv)) ,
                   (si.bus(N) <:   si.bus(N) ,
                                   (si.bus(N) :> _)) :
      ro.interleave(N, 2) ,
      _ :  (par(i, N, *) :> _) / _ : ma.inv;
// -----------------------------------------------------------------------------

// m2.avg_pow(N, E[n]); --------------------------------------------------------
//
// Generalised mean.
//
// N+1 inputs:
//    E[n], exponent for each element in the set;
//    x1[n];
//    ...
//    xN-1[n];
//    xN[n].
//
// 1 outputs:
//    y[n], generalised mean of a set of N elements.
//
// 1 compile-time arguments:
//    N, (integere) number of input signals.
//
avg_pow(N, m) = si.bus(N) : par(i, N, pow(m)) :> / (N) : pow(1 / m);
// -----------------------------------------------------------------------------

// m2.avg_quad(N); -------------------------------------------------------------
//
// Quadratic mean.
//
// N inputs:
//    x1[n];
//    ...
//    xN-1[n];
//    xN[n].
//
// 1 outputs:
//    y[n], quadratic mean of the input signals.
//
// 1 compile-time arguments:
//    N, (integer) number of input signals.
//
avg_quad(N) = si.bus(N) : par(i, N, _ <: *) :> / (N) : sqrt;
// -----------------------------------------------------------------------------

// m2.bip(x[n]); ---------------------------------------------------------------
//
// Unipolar to bipolar signal conversion: [0; 1] range to [-1; 1] range.
//
// 1 inputs:
//    x[n].
//
// 1 outputs:
//    y[n], bipolarised input.
//
bip(x) = x * 2 - 1;
// -----------------------------------------------------------------------------

// m2.complement(x[n]); --------------------------------------------------------
//
// Complement.
//
// 1 inputs:
//    x[n].
//
// 1 outputs:
//    y[n], 1 - x[n].
//
complement(x) = 1 - x;
// -----------------------------------------------------------------------------

// m2.dec2bin(N); --------------------------------------------------------------
//
// It converts a decimal integer (N) into a Faust list containing the binary
// digits, that is, the binary digits in parallel.
//
// 0 inputs.
//
// M = ceil(ma.log2(N)) outputs:
//    y1[n],
//    y2[n],
//    ...,
//    yM[n], binary digits representing N.
//
// 1 compile-time arguments:
//    N, decimal integer number.
//
dec2bin(0) = 0:!;
dec2bin(N) =   dec2bin(int(N / 2)) , 
               N % 2;
// -----------------------------------------------------------------------------

// m2.delta(S, dt[n], x[n]); ---------------------------------------------------
//
// First derivative using linear interpolation delay lines, hence
// allowing fractional differentiation periods.
//
// 2 inputs:
//    dt[n], differentiation period in seconds;
//    x[n].
//
// 1 outputs:
//    y[n], first derivative of x[n].
//
// 1 compile-time arguments:
//    S, maximum differentiation period in seconds.
//
delta(s, t, in) =  in - d2.del_lin(s, t, in);
// -----------------------------------------------------------------------------

// m2.delta2(S, dt[n], x[n]); ---------------------------------------------------
//
// Second derivative using linear interpolation delay lines, hence
// allowing fractional differentiation periods.
//
// 2 inputs:
//    dt[n], differentiation period in seconds;
//    x[n].
//
// 1 outputs:
//    y[n], second derivative of x[n].
//
// 1 compile-time arguments:
//    S, maximum differentiation period in seconds.
//
delta2(s, t, in) = delta(s, t, in) : delta(s, t);
// -----------------------------------------------------------------------------

// m2.diff(x[n]); --------------------------------------------------------------
//
// Differentiator: special case of a delta-function where the
// differentiation period is 1 / SR.
//
// 1 inputs:
//    x[n].
//
// 1 outputs:
//    y[n], first derivative of x[n].
//
diff(x) = x - x';
// -----------------------------------------------------------------------------

// m2.div(x1[n], x2[n]); -------------------------------------------------------
//
// Divider that avoids divide-by-zero by limiting the denominator to the
// smallest representable value. Essentially, the values of the
// denominator between -epsilon and epsilon are excluded. The corner
// case of x2 = 0 is clipped to positive epsilon.
//
// For efficiency, for positive denominators the divide-by-zero can
// simply be dealt with as:
//    x1 / max(ma.EPSILON, x2);
//
// while for negative denominators we can use:
//
//    x1 / min(ma.EPSILON * -1, x2);
//
// m2.div covers both cases.
//
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], division safe from divide-by-zero.
//
div(x1, x2) = x1 / m2.if(  x2 < 0, 
                           min(ma.EPSILON * -1, x2), 
                           max(ma.EPSILON, x2));         
// -----------------------------------------------------------------------------

// m2.factorial(N); ------------------------------------------------------------
//
// N! – factorial of N.
//
// 0 inputs.
//
// 1 outputs:
//    y[n], N!.
//
// 1 compile-time arguments:
//    N, positive integer, number to factorialise.
factorial(0) = 0;
factorial(1) = 1;
factorial(N) = N * factorial(N - 1);
// -----------------------------------------------------------------------------

// m2.hp_and(x1[n], x2[n]); ----------------------------------------------------
//
// Hyperbolic paraboloid AND.
// 
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n].
//
hp_and(x, y) = x * y;
// -----------------------------------------------------------------------------

// m2.hp_imp(x1[n], x2[n]); ----------------------------------------------------
//
// Hyperbolic paraboloid IMPLIES.
// 
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n].
//
hp_imp(x, y) = 1 - x + x * y;
// -----------------------------------------------------------------------------

// m2.hp_nand(x1[n], x2[n]); ---------------------------------------------------
//
// Hyperbolic paraboloid NOT AND.
// 
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n].
//
hp_nand(x, y) = 1 - x * y;
// -----------------------------------------------------------------------------

// m2.hp_nimp(x1[n], x2[n]); ---------------------------------------------------
//
// Hyperbolic paraboloid NOT IMPLIES.
// 
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n].
//
hp_nimp(x, y) = x * (1 - y);
// -----------------------------------------------------------------------------

// m2.hp_nor(x1[n], x2[n]); ----------------------------------------------------
//
// Hyperbolic paraboloid NOT OR.
// 
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n].
//
hp_nor(x, y) = 1 - x - y + x * y;
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// hyperbolic paraboloid NOT excluding OR
// m2.hp_nxr(x1[n], x2[n]); ----------------------------------------------------
//
// Hyperbolic paraboloid NOT excluding OR.
// 
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n].
//
hp_nxr(x, y) = 1 - x - y + 2 * x * y;
// -----------------------------------------------------------------------------

// m2.hp_or(x1[n], x2[n]); -----------------------------------------------------
//
// Hyperbolic paraboloid OR.
// 
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n].
//
hp_or(x, y) = x + y - x * y;
// -----------------------------------------------------------------------------

// m2.hp_xor(x1[n], x2[n]); ----------------------------------------------------
//
// Hyperbolic paraboloid excluding OR.
// 
// 2 inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n].
//
hp_xor(x, y) = x + y - 2 * x * y;
// -----------------------------------------------------------------------------

// m2.interpolate_mn(M, N, I[n]); ----------------------------------------------
//
// Linear interpolation to circularly transition between between M blocks of 
// N signals ("spat" by Romain Michon). The function shifts through the
// M blocks based on an index in the range [0; 1], representing the
// beginning and end of an interpolation cycle. For example, if we have four
// blocks, the index from 0 to .25 is the transition between block one and
// two, .25 to .5 is the transition between two and three, .5 to .75 is the
// transition between three and four, and .75 to 1 is the transition
// between four and one.
//
// M*N+1 inputs:
//    I[n], interpolation index in the [0; 1] range performing a
//         complete interpolation cycle among the M blocks. 
//    x11[n];
//    ...
//    x1N-1[n];
//    x1N[n];
//    ...
//    xM-11[n];
//    ...
//    xM-1N-1[n];
//    xM-1N[n];
//    ...
//    xMN[n].
//
// N outputs:
//    y1[n];
//    ...
//    yN-1[n];
//    yN[n], interpolated N-signal block.
//
// 2 compile-time arguments:
//    M, (integer) number of blocks;
//    N, integer number of signals in each block.
//
interpolate_mn(m, n, index) =  spat(m, index, 1) , 
                               ro.interleave(n, m) : 
      ro.interleave(m, n + 1) :    par(i, m, (_ <: si.bus(n)) , 
                                   si.bus(n) : ro.interleave(n, 2) : 
           par(i, n, *)) :> si.bus(n)
      with {
           spat(n, a, d) = par(i, n, (scaler(i, n, a, d) ))
               with {
                   scaler(i, n, a, d) = (d / 2.0 + .5) * max(.0, 1.0 - 
                       abs(fmod(a + .5 + float(n - i) / n, 1.0) - .5) * n * d);
               };
      };
// -----------------------------------------------------------------------------

// m2.if(C[n], T[n], E[n]); ----------------------------------------------------
//
// If-then-else – unlike Faust's if-then-else, the condition is true for
// any value != than 0, whereas Faust gives false for |fractions| < 1.
//
// 3 inputs:
//    C[n], condition;
//    T[n], "then" signal;
//    E[n], "else" signal.
//
// 1 outputs:
//    y[n], which is either T[n] or E[n] depending on C[n].
//
if(cond, then, else) = cond != 0 , 
                       else , 
                       then : select2;
// -----------------------------------------------------------------------------

// m2.ifN((C1[n], T1[n], ..., CN-1[n], TN-1[n], CN[n], TN[n], E[n])); ----------
//
// If-then-else-if-... with arbitrary number of conditions. 
// It takes pairs of IF-THEN couples plus a final ELSE. 
// These should be given as a list, hence within parentheses.
// Note that it only works if outputting single values for each
// condition due to Faust's limitations in list processing.
// Code by Oleg Nesterov.
//
// N*2+1 inputs:
//    C1[n]; 
//    T1[n]; 
//    ...; 
//    CN-1[n]; 
//    TN-1[n]; 
//    CN[n]; 
//    TN[n]; 
//    E[n].    (Note that the number of inputs depends on the specific
//             functions of each statement.)
//
// 1 outputs:
//    y[n], one of the T-signals or the E-signal.
//
ifN((c, t, e)) = m2.if(c, t, ifN(e));
ifN(e) = e;
// -----------------------------------------------------------------------------

// m2.inv(x[n]); ---------------------------------------------------------------
//
// INF-safe inverse.
//
// 1 inputs:
//    x[n].
//
// 1 outputs:
//    1 / x[n].
//
inv(x) = div(1, x);
// -----------------------------------------------------------------------------

// m2.line(S[n]); --------------------------------------------------------------
//
// Line function. Note that the function does not start from 0. If you
// require a precise behaviour, you can use the following:
//    m2.line(ba.select2(1', 0, S[n]));
//
// 1 inputs:
//    S[n], the slope of the line (y/x ratio).
//
// 1 outputs:
//    y[n], the line function.
//
line(s) =  + (s / ma.SR)
           ~ _;
// -----------------------------------------------------------------------------

// m2.line_reset(S[n], reset[n]); ----------------------------------------------
//
// Line function with reset input. Note that the function does not start 
// from 0 until it is reset. If you require a precise behaviour from the very 
// beginning, you can use the following:
//    m2.line_reset(ba.select2(1', 0, S[n]), reset[n]);
//
// 1 inputs:
//    S[n], the slope of the line (y/x ratio);
//    reset[n], it resets the line to 0 if its value is non-zero.
//
// 1 outputs:
//    y[n], the line function.
//
line_reset(rate, reset) =  + (rate / ma.SR * r)
                           ~ * (r)
      with {
           r = 1 - (reset != 0);
      };
// -----------------------------------------------------------------------------

// m2.map_lin(L[n], H[n], x[n]); -----------------------------------------------
//
// Linear mapping of an input signal in the range [0; 1] on to an arbitrary
// range determined by signals.
//
// 3 inputs:
//    L[n], lower edge of the range;
//    H[n], upper edge of the range;
//    x[n], input [0; 1].
//
// 1 outputs:
//    y[n], mapped x[n].
//
map_lin(lower, upper, x) = x * (upper - lower) + lower;
// -----------------------------------------------------------------------------

// m2.map_par(T[n], V[n], S[n], x[n]); -----------------------------------------
//
// Parabolic mapping of an input signal in the range [0; 1] on to a
// parabola whose curvature, vertex, and sides are determined by signals.
//
// 4 inputs:
//    T[n], tension parameter (curvature), the exponent, which is
//             constrained to be an even integer;
//    V[n], vertex of the parabola;
//    S[n], value of the sides of the parabola at the minimum and
//             maximum values of the input signal (0 and 1).
//    x[n], input [0; 1].
//
// 1 outputs:
//    y[n], mapped x[n].
//
map_par(t, vertex, sides, x) = x * 2 - 1 : pow(t_1) : m2.map_lin(vertex, sides)
      with {
           t_1 = int(t) * 2;
      };
// -----------------------------------------------------------------------------

// m2.map_pcw(S[n], E1[n], L1[n], H1[n], E2[n], L2[n], H2[n], x[n]); -----------
//
// Piece-wise mapping of an input signal in the range [0; 1] on to two
// segments with independent curves and ranges determined by signals.
//
// 8 inputs:
//    S[n], split-point up until the characteristics of the first
//             segment apply, where as those from the second segment
//             apply if the signal is above it;
//    E1[n], exponent for the first segment;
//    L1[n], lower edge of the first segment;
//    H1[n], upper edge of the first segment;
//    E2[n], exponent of the second segment;
//    L2[n], lower edge of the second segment;
//    H2[n], upper edge of the second segment;
//    x[n], input in the range [0; 1].
//
// 1 outputs:
//    y[n], mapped x[n].
//
map_pcw(split, exp1, l1, u1, exp2, l2, u2, x) = 
      m2.if(   x <= split, 
               map_pow(exp1, l1, u1, x), 
               m2.map_pow(exp2, l2, u2, x));
// -----------------------------------------------------------------------------

// m2.map_log(T[n], L[n], H[n], x[n]); -----------------------------------------
//
// Mapping of an input signal in the range [0; 1] on to a logarithmic
// curve with arbitrary ranges and curvature determined by signals.
//
// 4 inputs:
//    T[n], `tension` parameter – curvature of the log function;
//    L[n], lower edge of the function;
//    H[n], upper edge of the function;
//    x[n], input in the range [0; 1].
//
// 1 outputs:
//    y[n], mapped x[n].
//
map_log(t, lower, upper, x) = log(x * (t - 1) + 1) / log(t) : 
      m2.map_lin(lower, upper);
// -----------------------------------------------------------------------------

// m2.map_pow(T[n], L[n], H[n], x[n]); -----------------------------------------
//
// Mapping of an input signal in the range [0; 1] on to a power curve
// with arbitrary curvature and ranges determined by signals.
//
// 4 inputs:
//    T[n], `tension` parameter – curvature of the power function;
//    L[n], lower edge of the function;
//    H[n], upper edge of the function;
//    x[n], input in the range [0; 1].
//
// 1 outputs:
//    y[n], mapped x[n].
//
map_pow(t, lower, upper, x) = pow(x, t) : m2.map_lin(lower, upper);
// -----------------------------------------------------------------------------

// m2.matrix(R, C); ------------------------------------------------------------
//
// R-input, C-output matrix:
//
// a11 a12 … a1C
// a21 a22 … a2C
//  ⋮   ⋮  ⋱  ⋮
// aR1 aR2 … aRC
// 
// R+R*C inputs:
//    R, input signals to be distributed through the C outputs;
//    R*C, coefficients as shown in the diagram above;
//
// C outputs.
//
// 2 compile-time arguments:
//    R, (integer) number of rows;
//    C, (integer) number columns.
//
matrix(r, c) = (si.bus(r), ro.interleave(c, r)) : ro.interleave(r, c + 1) :
      par(i, r, (_ <: si.bus(c)) , 
      si.bus(c) : ro.interleave(c, 2) : par(i, c, *)) :> si.bus(c);
// -----------------------------------------------------------------------------

// m2.maxN(N); -----------------------------------------------------------------
//
// It returns the max value between a specified number of input signals.
//
// N inputs.
//
// 1 outputs:
//    y[n], max value between the N signals.
//
// 1 compile-time arguments:
//    N, (integer) number of input signals.
//
maxN(1) = _;
maxN(2) = max;
maxN(N) = max(maxN(N - 1));
// -----------------------------------------------------------------------------

// m2.minN(N); -----------------------------------------------------------------
//
// It returns the min value between a specified number of input signals.
//
// N inputs.
//
// 1 outputs:
//    y[n], min value between the N signals.
//
// 1 compile-time arguments:
//    N, (integer) number of input signals.
//
minN(1) = _;
minN(2) = min;
minN(N) = min(minN(N - 1));
// -----------------------------------------------------------------------------

// m2.ny; ----------------------------------------------------------------------
//
// Nyquist or half the samplerate.
//
// 0 inputs.
//
// 1 outputs:
//    y[n], SR/2.
//
ny = ma.SR / 2;
// -----------------------------------------------------------------------------

// m2.ph(F[n], reset[n]); ------------------------------------------------------
//
// Phasor with phase reset.
//
// 2 inputs:
//    F[n], frequency in Hz;
//    reset[n], it resets the phasor to 0 for values different than 0.
//
// 1 outputs:
//    y[n], phasor oscillator.
//
ph(freq, reset) = freq / ma.SR * r :   (+ : ma.decimal) 
                                       ~ * (r)
      with {
           r = 1 - (reset != 0);
      };
// -----------------------------------------------------------------------------

// m2.primes; ------------------------------------------------------------------
//
// First 64 prime numbers.
//
// 0 inputs.
//
// 64 outputs:
//    2;
//    3;
//    5;
//    ...;
//    311.
//
primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,
67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149,
151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311);
// -----------------------------------------------------------------------------

// m2.prime_base_pow(N, E[n]); -------------------------------------------------
//
// N-th prime number raised to a power.
//
// 1 inputs:
//    E[n], exponent.
//
// 1 outputs:
//    y[n], N-th prime number raised to a power.
//
// 1 compile-time arguments:
//    N, (integer) N-th prime number up to 64.
//
prime_base_pow(N, exponent) = pow(ba.take(N, primes), exponent);
// -----------------------------------------------------------------------------

// m2.relay_hysteron(A[n], B[n], x[n]); ----------------------------------------
//
// Relay hysteron – the basic building block of the Preisach model.
//
// 3 inputs:
//    A[n], lower edge;
//    B[n], upper edge;
//    x[n].
//
// 1 outputs:
//    y[n], relay output, 0 or 1 (non-active or active).
//
relay_hysteron(alpha, beta, x) =   loop 
                                   ~ _
with {
    loop(fb) = m2.if(  x <= alpha, 
                       0, m2.if(   x >= beta, 
                                   1, 
                                   fb));
};
// -----------------------------------------------------------------------------

// m2.round_pow2(x[n]); --------------------------------------------------------
//
// Closest power-of-two to the input signal.
//
// 1 inputs:
//    x[n].
//
// 1 outputs:
//    y[n], closest power-of-two to x[n].
//
round_pow2(x) = 2 ^ (rint(ma.log2(x)));
// -----------------------------------------------------------------------------

// m2.rt9(T[n]); ---------------------------------------------------------------
//
// One-pole coefficient for ~9 dB exponential decay (e^-1 factor) in a desired
// time specified in seconds.
//
// 1 inputs:
//    T[n], decay time in seconds.
//
// 1 outputs:
//    y[n], pole position.
//
rt9(t) = ba.tau2pole(t);
// -----------------------------------------------------------------------------

// m2.rt19(T[n]); --------------------------------------------------------------
//
// One-pole coefficient for ~19 dB exponential decay (e^-2.2 factor factor) 
// in a desired time specified in seconds. This decay factor is used in 
// [Zölzer 2008] for the calculation of RMS with 1-pole filters.
//
// 1 inputs:
//    T[n], decay time in seconds.
//
// 1 outputs:
//    y[n], pole position.
//
rt19(t) = ba.tau2pole(t / 2.2);
// -----------------------------------------------------------------------------

// m2.rt55(T[n]); --------------------------------------------------------------
//
// One-pole coefficient for ~55 dB exponential decay (e^(-2pi) factor) in a 
// desired time specified in seconds.
// This coefficient calculation is found in [Chamberlin 1985] for the
// implementation of one-pole lowpass filters that simulate the dis/charging
// behaviours of a capacitor.
//
// 1 inputs:
//    T[n], decay time in seconds.
//
// 1 outputs:
//    y[n], pole position.
//
rt55(t) = ba.tau2pole(t / m2.twopi);
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// 1-pole coeff. for ~60 dB decay (e^-log(1000) factor) in a desired time "t".
// m2.rt60(T[n]); --------------------------------------------------------------
//
// One-pole coefficient for ~60 dB exponential decay (e^-log(1000) factor) in a 
// desired time specified in seconds.
// This coefficient calculation is commonly seen in the design of
// artificial reverberation.
//
// 1 inputs:
//    T[n], decay time in seconds.
//
// 1 outputs:
//    y[n], pole position.
//
rt60(t) = ba.tau2pole(t / 6.907755279);
// -----------------------------------------------------------------------------

// m2.sd(N); -------------------------------------------------------------------
//
// Stanrdard deviation.
//
// N inputs.
//
// 1 outputs:
//    y[n], standard deviation between the N input signals.
//
// 1 compile-time arguments:
//    N, input signals.
//
sd(N) = sqrt(var(N));
// -----------------------------------------------------------------------------

// m2.seq_catalan(N); ----------------------------------------------------------
//
// First N numbers in the Catalan sequence:
//    1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, ...
//
// Note that, in single-precision, the function is correct only up to
// the 7th element.
//
// 0 inputs.
//
// N outputs:
//    y1[n];
//    y2[n];
//    ...;
//    yN-1[n];
//    y[N], the first N numbers in the Catalan sequence.
//
// 1 compile-time arguments:
//    N, the first N numbers in the Catalan sequence.
//
seq_catalan(1) = 1;
seq_catalan(N) =   1 , 
                   par(i, N - 1, factorial(2 * (i + 1)) / 
                       (factorial(i + 1 + 1) * factorial(i + 1)));
// -----------------------------------------------------------------------------

// m2.seq_fibonacci(N); --------------------------------------------------------
//
// First N numbers of the Fibonacci sequence:
//    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...
//
// 0 inputs.
//
// N outputs:
//    y1[n];
//    y2[n];
//    ...;
//    yN-1[n];
//    y[N], the first N numbers in the Fibonacci sequence.
//
// 1 compile-time arguments:
//    N, the first N numbers in the Fibonacci sequence.
//
seq_fibonacci(1) = 0;
seq_fibonacci(2) = 0 , 
                   1;
seq_fibonacci(3) = 0 ,
                   1 ,
                   1;
seq_fibonacci(N) = seq_fibonacci(N - 1) <: si.bus(N - 1) ,
                                           (   par(i, N - 3, !) ,
                                               si.bus(2) :> _);
// -----------------------------------------------------------------------------

// m2.seq_hexagonal(N); --------------------------------------------------------
//
// First N numbers of the hexagonal sequence:
//    1, 6, 15, 28, 45, 66, 91, 120, 153, 190, ...
//
// 0 inputs.
//
// N outputs:
//    y1[n];
//    y2[n];
//    ...;
//    yN-1[n];
//    y[N], the first N numbers in the hexagonal sequence.
//
// 1 compile-time arguments:
//    N, the first N numbers in the hexagonal sequence.
//
seq_hexagonal(N) = par(i, N, 2 * (i + 1) * (2 * (i + 1) - 1) / 2);
// -----------------------------------------------------------------------------

// m2.seq_lazy_caterer(N); -----------------------------------------------------
//
// First N numbers of the Lazy Caterer sequence:
//    1, 2, 4, 7, 11, 16, 22, 29, 37, 46, ...
//
// 0 inputs.
//
// N outputs:
//    y1[n];
//    y2[n];
//    ...;
//    yN-1[n];
//    y[N], the first N numbers in the Lazy Caterer sequence.
//
// 1 compile-time arguments:
//    N, the first N numbers in the Lazy Caterer sequence.
//
seq_lazy_caterer(N) = par(i, N, (i ^ 2 + i + 2) / 2);
// -----------------------------------------------------------------------------

// m2.seq_magic_number(N); -----------------------------------------------------
//
// First N numbers of the Magic Number sequence: 
//    15, 34, 65, 111, 175, 260, 369, 505, 671, 870, ...
//
// The Magic Number is a constant for an Mth-order square matrix, 
// assuming M > 2, of integer values, with the max value being M^2, 
// where the constant corresponds to the sum of the numbers in any 
// of its rows, columns, or diagonals.
//
// Example of order-3 magic square (constant 15):
//
//    4 9 2
//    3 5 7
//    8 1 6
//
// 0 inputs.
//
// N outputs:
//    y1[n];
//    y2[n];
//    ...;
//    yN-1[n];
//    y[N], the first N numbers in the Magic Number sequence.
//
// 1 compile-time arguments:
//    N, first N numbers in the Magic Number sequence.
//
seq_magic_number(N) = par(i, N, (i + 3) * ((i + 3) ^ 2 + 1) / 2);
// -----------------------------------------------------------------------------

// m2.seq_pentagonal(N); -------------------------------------------------------
//
// First N numbers of the pentagonal sequence:
//    1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
//
// 0 inputs.
//
// N outputs:
//    y1[n];
//    y2[n];
//    ...;
//    yN-1[n];
//    y[N], the first N numbers in the pentagonal sequence.
//
// 1 compile-time arguments:
//    N, the first N numbers in the pentagonal sequence.
//
seq_pentagonal(N) = par(i, N, (3 * (i + 1) ^ 2 - (i + 1)) / 2);
// -----------------------------------------------------------------------------

// m2.seq_square(N); -----------------------------------------------------------
//
// First N numbers of the square sequence:
//    1, 4, 9, 16, 25, 36, 49, 64, 81, 100, ...
//
// 0 inputs.
//
// N outputs:
//    y1[n];
//    y2[n];
//    ...;
//    yN-1[n];
//    y[N], the first N numbers in the square sequence.
//
// 1 compile-time arguments:
//    N, the first N numbers in the square sequence.
//
seq_square(N) = par(i, N, (i + 1) ^ 2);
// -----------------------------------------------------------------------------

// m2.seq_triangular(N); -------------------------------------------------------
//
// First N numbers of the triangular sequence:
//    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
//
// 0 inputs.
//
// N outputs:
//    y1[n];
//    y2[n];
//    ...;
//    yN-1[n];
//    y[N], the first N numbers in the triangular sequence.
//
// 1 compile-time arguments:
//    N, the first N numbers in the triangular sequence.
//
seq_triangular(N) = par(i, N, (i + 1) * (i + 1 + 1) / 2);
// -----------------------------------------------------------------------------

// m2.sp; ----------------------------------------------------------------------
//
// Sampling period.
//
// 0 inputs.
//
// 1 outputs:
//    y[n], sampling period, 1 / SR.
//
sp = 1 / ma.SR;
// -----------------------------------------------------------------------------

// m2.topologies(R, C, I[n]); --------------------------------------------------
//
// Linear interpolation to circularly shift through matrix topologies
// according to an index in the range [0; 1]. There are four topologies
// with arbitrary rows and columns: full, anti-diagonal, diagonal, and
// right-shifted diagonal. The ranges to transition among the four topologies
// are 0 to .25 to shift from the first to the second topology, .25 to
// .5 from the second to the third, .5 to .75 from the third to the fourth,
// and .75 to 1 from the fourth and back to the first one.
//
// The output of this function can be used as the coefficients for an
// m2.matrix function that has the same number of rows and columns.
//
// 1 inputs:
//    I[n], interpolation index in the range [0; 1].
//
// R*C outputs:
//    y11 y12 … y1C
//    y21 y22 … y2C
//     ⋮   ⋮  ⋱  ⋮
//    yR1 yR2 … yRC
// 
// 2 compile-time arguments:
//    R, (integer) number of rows;
//    C, (integer) number columns.
// 
topologies(r, c, type) =   top_full(r, c) ,
                           top_anti_diag(r, c) ,
                           top_diagonal(r, c) ,
                           top_diag_shift(r, c, 1) : 
      interpolate_mn(4, r * c, type);
// -----------------------------------------------------------------------------

// m2.top_anti_diag(R, C); -----------------------------------------------------
//
// Anti-diagonal matrix topology.
//
// Example for a 4x4 matrix:
//
//    0 1 1 1
//    1 0 1 1
//    1 1 0 1
//    1 1 1 0
//
// 0 inputs.
//
// R*C outputs:
//    y11 y12 … y1C
//    y21 y22 … y2C
//     ⋮   ⋮  ⋱  ⋮
//    yR1 yR2 … yRC
//
// 2 compile-time arguments:
//    R, (integer) number of rows;
//    C, (integer) number columns.
// 
top_anti_diag(r, c) = par(i, r, par(j, c, (j % r) != (i % c)));
// -----------------------------------------------------------------------------

// m2.top_diagonal(R, C); ------------------------------------------------------
//
// Diagonal matrix topology.
//
// Example for a 4x4 matrix:
//
//    1 0 0 0
//    0 1 0 0
//    0 0 1 0
//    0 0 0 1
//
// 0 inputs.
//
// R*C outputs:
//    y11 y12 … y1C
//    y21 y22 … y2C
//     ⋮   ⋮  ⋱  ⋮
//    yR1 yR2 … yRC
//
// 2 compile-time arguments:
//    R, (integer) number of rows;
//    C, (integer) number columns.
//
top_diagonal(r, c) = par(i, r, par(j, c, (j % r) == (i % c)));
// -----------------------------------------------------------------------------

// m2.top_diag_shift(R, C, S[n]); ----------------------------------------------
//
// Shifted diagonal matrix topology.
//
// Example for a 4x4 matrix and a one-position-shift:
//
//    0 1 0 0
//    0 0 1 0
//    0 0 0 1
//    1 0 0 0
//
// 1 inputs:
//    S[n], cast to integer, it determines the shift amount.
//
// R*C outputs:
//    y11 y12 … y1C
//    y21 y22 … y2C
//     ⋮   ⋮  ⋱  ⋮
//    yR1 yR2 … yRC
//
// 2 compile-time arguments:
//    R, (integer) number of rows;
//    C, (integer) number columns.
//
top_diag_shift(r, c, s) = 
      par(i, r, par(j, c, (j  % r) == ((i + int(s)) % c)));
// -----------------------------------------------------------------------------

// m2.top_full(R, C); ----------------------------------------------------------
//
// Fully-connected matrix topology. Essentially, the function outputs as
// many 1s in parallel as the product between the specified rows and columns.
//
// Example for a 4x4 matrix:
//
//    1 1 1 1
//    1 1 1 1
//    1 1 1 1
//    1 1 1 1
//
// 0 inputs.
//
// R*C outputs:
//    y11 y12 … y1C
//    y21 y22 … y2C
//     ⋮   ⋮  ⋱  ⋮
//    yR1 yR2 … yRC
//
// 2 compile-time arguments:
//    R, (integer) number of rows;
//    C, (integer) number columns.
//
top_full(r, c) = 1 <: si.bus(r * c);
// -----------------------------------------------------------------------------

// m2.top_tri_low(R, C); -------------------------------------------------------
//
// Lower-triangle matrix topology.
//
// Example for a 4x4 matrix:
//
//    1 0 0 0
//    1 1 0 0
//    1 1 1 0
//    1 1 1 1
//
// 0 inputs.
//
// R*C outputs:
//    y11 y12 … y1C
//    y21 y22 … y2C
//     ⋮   ⋮  ⋱  ⋮
//    yR1 yR2 … yRC
//
// 2 compile-time arguments:
//    R, (integer) number of rows;
//    C, (integer) number columns.
//
top_tri_low(r, c) = par(i, r, par(j, c, (j % r) <= (i % c)));
// -----------------------------------------------------------------------------

// m2.top_tri_up(R, C); -----000------------------------------------------------
//
// Upper-triangle matrix topology.
//
// Example for a 4x4 matrix:
//
//    1 1 1 1
//    0 1 1 1
//    0 0 1 1
//    0 0 0 1
//
// 0 inputs.
//
// R*C outputs:
//    y11 y12 … y1C
//    y21 y22 … y2C
//     ⋮   ⋮  ⋱  ⋮
//    yR1 yR2 … yRC
//
// 2 compile-time arguments:
//    R, (integer) number of rows;
//    C, (integer) number columns.
//
top_tri_up(r, c) = par(i, r, par(j, c, (j % r) >= (i % c)));
// -----------------------------------------------------------------------------

// m2.uni(x[n]); ---------------------------------------------------------------
//
// Function to convert a bipolar signal to unipolar, assuming an input
// in the range [-1; 1].
//
// 1 inputs:
//    x[n], input signal assumed in the range [-1; 1].
//
// 1 outputs:
//    y[n], output in the range [0; 1].
//
uni(x) = (x + 1) / 2;
// -----------------------------------------------------------------------------

// m2.twopi --------------------------------------------------------------------
//
// 2π constant.
//
// 0 inputs.
//
// 1 outputs:
//    y[n], two times π.
//
twopi = 2 * ma.PI;
// -----------------------------------------------------------------------------

// m2.unit_log(T[n], x[n]); ----------------------------------------------------
//
// Logarithmic mapping of an input signal in the range [0; 1] into an
// output in the same range and arbitrary curvature (tension factor).
//
// 2 inputs:
//    T[n], curvature, tensione factor;
//    x[n], input in the range [0; 1].
//
// 1 outputs:
//    y[n], logarithmically-mapped x[n] in the range [0; 1].
//
unit_log(t, x) = log(x * (t - 1) + 1) / log(t);
// -----------------------------------------------------------------------------

// m2.var(N); ------------------------------------------------------------------
//
// Variance of a set of N elements.
//
// N inputs.
//
// 1 outputs:
//    y[n], variance of the N input signals.
//
// 1 compile-time arguments:
//    N, (integer) number of input signals.
//
var(N) = si.bus(N) <:  si.bus(N) ,
                       (si.bus(N) :> / (N) <: si.bus(N)) :
      ro.interleave(N, 2) : par(i, N, - <: *) :> / (N);
// -----------------------------------------------------------------------------

// m2.w(F[n]); -----------------------------------------------------------------
//
// Angular frequency.
//
// 1 inputs:
//    F[n], frequency in Hz.
//
// 1 outputs:
//    y[n], angular frequency between 0 and π, assuming an input between
//             0 and Nyquist.
//
w(x) = x * m2.twopi / ma.SR;
// -----------------------------------------------------------------------------

// m2.window_hann(ph[n]); -------------------------------------------------------
//
// Hann window.
//
// 1 inputs:
//    ph[n], phase of the function where a full cycle is in the range [0; 1].
//
// 1 outputs:
//    y[n], Hann function.
//
window_hann(x) = sin(ma.PI * x) <: *;
// -----------------------------------------------------------------------------

// m2.window_sine(ph[n]); ------------------------------------------------------
//
// Sine window.
//
// 1 inputs:
//    ph[n], phase of the function where a full cycle is in the range [0; 1].
//
// 1 outputs:
//    y[n], Sine function.
//
window_sine(x) = sin(ma.PI * x);
// -----------------------------------------------------------------------------

// m2.wrap(L[n], H[n], x[n]); --------------------------------------------------
//
// Wrapping function.
//
// 3 inputs:
//    L[n], lower edge;
//    H[n], upper edge;
//    x[n].
//
// 1 outputs:
//    y[n], wrapped-up x[n].
//
wrap(lower, upper, x) = 
      (x - lower) / (upper - lower) : ma.decimal * (upper - lower) + lower;
// -----------------------------------------------------------------------------

// m2.y_and(x1[n], x2[n]); -----------------------------------------------------
//
// Yager AND.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] AND x2[n].
//
y_and(x, y) = 1 - min(1, sqrt((1 - x) ^ 2 + (1 - y) ^ 2));
// -----------------------------------------------------------------------------

// m2.y_or(x1[n], x2[n]); ------------------------------------------------------
//
// Yager OR.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] OR x2[n].
//
y_or(x, y) = min(1, (x ^ 2 + y ^ 2) ^ 2);
// -----------------------------------------------------------------------------

// m2.zeropad_up(N, list); -----------------------------------------------------
//
// This function adds N zeros at the beginning of a list.
//
// 0 inputs.
//
// N+ba.count(list) outputs.
//
// 1 compile-time arguments:
//    N, number of zeros to be added.
//
zeropad_up(0, x) = x;
zeropad_up(N, x) = par(i, N, 0) , x;
// -----------------------------------------------------------------------------

// m2.zeropad_down(N, list); ---------------------------------------------------
//
// This function adds N zeros at the end of a list.
//
// 0 inputs.
//
// N+ba.count(list) outputs.
//
// 1 compile-time arguments:
//    N, number of zeros to be added.
//
zeropad_down(0, x) = x;
zeropad_down(N, x) = par(i, N, 0) , x;
// -----------------------------------------------------------------------------

// m2.z_and(x1[n], x2[n]); -----------------------------------------------------
//
// Zadeh AND.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] AND x2[n].
//
z_and(x, y) = min(x, y);
// -----------------------------------------------------------------------------

// m2.z_imp(x1[n], x2[n]); -----------------------------------------------------
//
// Zadeh IMPLIES.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] IMPLIES x2[n].
//
z_imp(x, y) = 1 - min(x, 1 - y);
// -----------------------------------------------------------------------------

// m2.z_nand(x1[n], x2[n]); ----------------------------------------------------
//
// Zadeh NOT AND.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] NAND x2[n].
//
z_nand(x, y) = 1 - min(x, y);
// -----------------------------------------------------------------------------

// m2.z_nimp(x1[n], x2[n]); ----------------------------------------------------
//
// Zadeh NOT IMPLIES.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] NOT IMPLIES x2[n].
//
z_nimp(x, y) = min(x, 1 - y);
// -----------------------------------------------------------------------------

// m2.z_nor(x1[n], x2[n]); -----------------------------------------------------
//
// Zadeh NOT OR.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] NOR x2[n].
//
z_nor(x, y) = 1 - max(x, y);
// -----------------------------------------------------------------------------

// m2.z_nxr(x1[n], x2[n]); -----------------------------------------------------
//
// Zadeh NOT XOR.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] NXR x2[n].
//
z_nxr(x, y) = 1 - x - y + 2 * min(x, y);
// -----------------------------------------------------------------------------

// m2.z_or(x1[n], x2[n]); ------------------------------------------------------
//
// Zadeh OR.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] OR x2[n].
//
z_or(x, y) = max(x, y);
// -----------------------------------------------------------------------------

// m2.z_xor(x1[n], x2[n]); -----------------------------------------------------
//
// Zadeh XOR.
//
// inputs:
//    x1[n];
//    x2[n].
//
// 1 outputs:
//    y[n], x1[n] XOR x2[n].
//
z_xor(x, y) = x + Y - 2 * min(x, y);
// -----------------------------------------------------------------------------
