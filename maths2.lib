// MORE MATH

ba = library("basics.lib");
de = library("delays.lib");
d2 = library("delays2.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
ro = library("routes.lib");
si = library("signals.lib");

primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,
67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149,
151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311);

// Nyquist
ny = ma.SR/2;

// sampling period
speriod = 1/ma.SR;

// NAN-safe divider
div(x1, x2) = ba.if(x2 : ==(0), 0, (x1 ,
                                    x2 : /));

// NAN-safe inverse
inv(x) =   1,
           x : div;

// closest power of 2
round_pow2(x) = 2^(ma.log2(x) : rint);

// wrap around a range
wrap(lower, upper, x) = (x-lower)/(upper-lower) : ma.decimal : *(upper-lower) : +(lower);

// angular frequency
w(x) = x*2*ma.PI/ma.SR;

// 1-pole coeff. for 60-dB decay in a desired time
rt60(x) =   .001 ,
            (   speriod ,
                max(x, .001) : /) : pow;

// n-th prime number raised to a power
prime_base_pow(n) = ba.take(n, primes) ,
                    _ : pow;

// line: in signal sets x/y ratio
line =  _ ,
        ma.SR : / : +
                    ~ _;

// line with reset input
line_reset(rate, reset) =  rate ,
                           ma.SR : / : +
                                       ~ *(1-(reset : !=(0)));

// phasor with phase reset
ph(freq, reset) = freq/ma.SR : (+ : ma.decimal) ~ *(1-(reset : !=(0)));

// complement
complement(x) = 1-x;

// linear interpolation between m blocks of n signals
interpolate_mn(m, n, index) = spat(m, index, 1) , ro.interleave(n, m) : ro.interleave(m, n+1) : par(i, m, (_ <: si.bus(n)) , si.bus(n) : ro.interleave(n, 2) : par(i, n, *)) :> si.bus(n)
with {
      spat(n,a,d) = 1 <: par(i, n, *(scaler(i, n, a, d) ))
      with {
       scaler(i,n,a,d) = (d/2.0+0.5)*max(0.0, 1.0 - abs(fmod(a+0.5+float(n-i)/n, 1.0) - 0.5) * n * d);
      };
};

// r-input, c-output matrix
matrix(r, c) = (si.bus(r), ro.interleave(c, r)) : ro.interleave(r, c+1) : par(i, r, (_ <:    si.bus(c)), 
                               si.bus(c) : ro.interleave(c, 2) : par(i, c, *)) :> si.bus(c);

// linearly interpolated topologies for matrix function
topologies(r, c, type) =   top_full(r, c),
                           top_anti_diag(r, c),
                           top_diagonal(r, c),
                           top_diag_shift(r, c, 1) : interpolate_mn(4, r*c, type);

// fully-connected topology for matrix function
top_full(r, c) = 1 <: si.bus(r*c);

// lower triangular topology for matrix function
top_tri_low(r, c) = par(i, r, par(j, c, ba.if((j : %(r))<=(i : %(c)), 1, 0)));

// upper triangular topology for matrix function
top_tri_up(r, c) = par(i, r, par(j, c, ba.if((j : %(r))>=(i : %(c)), 1, 0)));

// diagonal topology for matrix function
top_diagonal(r, c) = par(i, r, par(j, c, ba.if((j : %(r))==(i : %(c)), 1, 0)));

// shifted diagonal topology for matrix function
top_diag_shift(r, c, s) = par(i, r, par(j, c, ba.if((j : %(r))==(i+s : %(c)), 1, 0)));

// anti-diagonal topology for matrix function
top_anti_diag(r, c) = par(i, r, par(j, c, ba.if((j : %(r))!=(i : %(c)), 1, 0)));

// differentiator
diff(x) = x-x';

// first derivative
delta(s, t, in) =  in ,
                   d2.del_lin(s, t, in) : -;

// second derivative
delta2(s, t, in) = delta(s, t, in) : delta(s, t);

// linear mapping
map_lin(lower, upper, x) = x*(upper-lower)+lower;

// power mapping; t is the exponent or tension parameter
map_pow(t, lower, upper, x) = x : pow(t) : map_lin(lower, upper);

// logarithmic mapping; t is the base acting as a tension parameter
map_log(t, lower, upper, x) = log(x*(t-1)+1)/log(t) : map_lin(lower, upper);

unit_log(t, x) = log(x*(t-1)+1)/log(t);

// parabolic mapping; t (must be an even int) is the tension parameter
map_par(t, lower, upper, x) = x*2-1 : pow(t_1) : map_lin(lower, upper)
with {
      t_1 = t : int : *(2);
};

// piece-wise mapping (two segments)
map_pcw(split, exp1, exp2, l1, u1, l2, u2, x) = ba.if( x : <=(split),
                                                       map_pow(exp1, l1, u1, x),
                                                       map_pow(exp2, l2, u2, x));

// Hann window
window_hann(x) = sin(ma.PI*x) <: *;

// Sine window
window_sine(x) = sin(ma.PI*x);
