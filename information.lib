// INFORMATION PROCESSING

ba = library("basics.lib");
fi = library("filters.lib");
f2 = library("filters2.lib");
ip = library("information.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
ro = library("routes.lib");
si = library("signals.lib");

// zero-crossing detection
zc(x) = x*x' : <(0);
                       
// zero-crossing rate
zcr(x, window) = zc(x) : f2.lp1p(_, window);

// infinitely fast attack and adjustable release
peak_env(in, release) = abs(in) :   max(_, _)
                                    ~ *(release : m2.rt60);

// hold peak for a time specified in seconds
peak_hold(in, release) = in : ba.peakholder(release*ma.SR);

// detects lower and upper peaks and holds them for a time (in s) specified by "release"
peaks(in, release) =   (   check_low 
                           ~ _),
                       (   check_high
                           ~ _)
with {
      check_low(s) =   (   in, 
                           s : <= <:   _, 
                                       (   1/release,
                                           _ : m2.ph : m2.diff : <(0)) : |),
                       s,
                       in : select2;
      check_high(s) =  (   in, 
                           s : >= <:   _, 
                                       (   1/release,
                                           _ : m2.ph : m2.diff : <(0)) : |),
  		       s,
                       in : select2;
};

// envelope following
env_fol(in, window) = in : abs : lp1p(_, window);

// root mean square measurement using lowpass
rms(in, window) = in <: * : f2.lp1p(_, window) : sqrt;

// RMS with fourth-order LP
rms4(in, window) = in <: * : seq(i, 4, _,
                                       window : f2.lp1p) : sqrt;

// function for equal-loudness contour
a_weighting(f) = (12194^2*f^4)/((f^2+20.6^2)*sqrt((f^2+107.7^2)*(f^2+737.9^2))*(f^2+12194^2));

loudness(in, window) = in <:   (   _,
                                   1/window : peak_env),
                               (   _,
                                   window : spec_ten*m2.ny : a_weighting) : *;
                               

// spectral energy (RMS) difference at a splitting point (Hz)
spec_bal(in, cf, window) =  in ,
                            cf : f2.crossover <:   (   _ ,
                                                       window : rms : *(-1)) ,
                                                   (   _ ,
                                                       window : rms) : +;

// spectral tendency (weighted mean)
spec_ten(in, window) =  (   (   in ,
                                _ ,
                                window : spec_bal) ,
                            (   in ,
                                window : rms) :  m2.div : *(window) : /(ma.SR) : f2.int_clip(_, 0, 1) : pow(4)) 
                        ~ *(m2.ny);

// noisiness
noisiness(in, window) = spec_ten(in, window) : *(m2.ny) <: (   in, 
                                                               _ : zcr : m2.unit_log(_, 10)),
                                                           (_ : m2.inv) : m2.delta : abs : f2.lp1p(_, window);

// roughness
roughness(in, window) = in <:  (   (   rms4(_, 100),
                                       .01 : m2.delta : abs),
                                   window : f2.lp1p),
                               rms(_, window) : m2.div;

// spectral spread
spec_spr(in, window) = (   (in,
                           spec_ten(in, window)) : (   _, 
                                                       _, 
                                                       10) : f2.bpbi : (   _, 
                                                                           window) : ip.rms),
                       (in,
                       window : ip.rms) : m2.div : m2.complement;

// dynamicity index based on RMS, spectral tendency and noisiness
dynamicity(in, window) =   ((rms(in, 15) : m2.unit_log(_, 10)),
                           (spec_ten(in, 15) : m2.unit_log(_, 10)),
                           (noisiness(in, 15) : m2.unit_log(_, 10))) : par(i, 3,  (_,
                                                                                   1/15) : m2.delta : abs : (  _,
                                                                                                               window) : f2.lp1p) :> m2.unit_log(_, 10) : ma.tanh;

// detects and integrates occurrences of signals within a specified range; with exponential decay in s
recurrence(in, lower, upper, t) = in <: (   >(lower),
                                           <=(upper) : &) : fi.pole(m2.rt60(t));

// normalised average absolute deviation around the mean
aad(n) = si.bus(n) <:  (si.bus(n),
                       (si.bus(n) :> /(n) <: si.bus(n)) : ro.interleave(n, 2) : par(i, n, (- : abs)) :> _),
                       (si.bus(n) :> /(n)) : m2.div : /((n-1)*2);

// provides an index of how heterogeneous the state space of a signal is; inputs are n for number of states (must be provided as an argument), source signal, lower edge of the state space, upper edge of the state space, memory of the analysis in s
heterogeneity(n) = si.bus(4) <: par(i, n, (    _,
                                               ((  _,
                                                   _,
                                                   n,
                                                   i) : region),
                                               (_ <: si.bus(3))) : ((   recurrence,
                                                                        _ : ip.peak_hold),
                                                                    1/_ : f2.lp1p)) : aad(n)
with {
      region(lower, upper, n, i) = lower+((upper-lower)/n)*i,
                                   lower+((upper-lower)/n)*(i+1);
};

// complexity index based on the edge of chaos of RMS, spectral tendency and noisiness
complexity(in, window) =   (rms(in, 15) : m2.unit_log(_, 10)),
                           (spec_ten(in, 15) : m2.unit_log(_, 10)),
                           (noisiness(in, 15) : m2.unit_log(_, 10)) : par(i, 3,    _,
                                                                                   0,
                                                                                   1,
                                                                                   window : heterogeneity(10)) : ( m2.div(_, t1),
                                                                                                                   m2.div(_, t2),
                                                                                                                   m2.div(_, t3)) : par(i, 3,  _,
                                                                                                                                               1/(window*2) : f2.lp1p) : par(i, 3, _,
                                                                                                                                                                                   window*2 : m2.delta : abs) :>   _, 
                                                                                                                                                                                                                   1/(window*2) : f2.lp1p : ma.tanh
with {
      t1 = ((rms(in, 15) : m2.unit_log(_, 10)),
           window : ip.peaks : ro.cross(2) : -) :  _,
                                                   1/window : f2.lp1p : m2.map_lin(_, .25, 1);
      t2 = ((spec_ten(in, 15) : m2.unit_log(_, 10)),
           window : ip.peaks : ro.cross(2) : -) :  _,
                                                   1/window : f2.lp1p : m2.map_lin(_, .25, 1);
      t3 = ((noisiness(in, 15) : m2.unit_log(_, 10)),
           window : ip.peaks : ro.cross(2) : -) :  _,
                                                   1/window : f2.lp1p : m2.map_lin(_, .25, 1);
};
