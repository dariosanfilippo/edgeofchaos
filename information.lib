/* Information processing algorithms in the time domain for low-level and high-level features.
 *
 * Copyright (c) 2019-2020, Dario Sanfilippo <sanfilippo.dario at gmail dot com> 
 *
 * All rights reserved.
 */

au = library("auxiliary.lib");
ba = library("basics.lib");
fi = library("filters.lib");
f2 = library("filters2.lib");
ip = library("information.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
ro = library("routes.lib");
si = library("signals.lib");

// function for equal-loudness contour
a_weighting(f) = (12194^2*f^4)/((f^2+20.6^2)*sqrt((f^2+107.7^2)*(f^2+737.9^2))
                   *(f^2+12194^2));

// Complexity measurement as edge-of-chaos detection, that is,  accumulation 
// of the variations in the heterogeneity of a state space.
complexity(max_dt, dt, window, x) = ip.heterogeneity10(window, x) :
      m2.delta(max_dt, dt) : abs : f2.lp1p(1/window);

// Dynamicity index as accumulation of the magnitude of the delta at a 
// specified dt (secs) and accumulation rate (window, in Hz).
// It is supposed to be used with infrasonic low-level information signals such as RMS, 
// spectral tendency, noisiness.
dynamicity(max_dt, dt, window, in) = m2.delta(max_dt, dt) : abs : f2.lp1p(window);

// envelope following
env_fol(window, in) = in : abs : lp1p(window);

// detects highest partial in a signal
highest_partial(window, in) =  (_ <:   _,
                                       (   _, 
                                           in : hp1p1z2 <: _,
                                                           _) :    (specbal, 
                                                                   rms(window) 
                                   : m2.div : /(ma.SR) : *(window) 
                                       : f2.int_clip(0, 1) <: *)) 
                               ~ *(m2.ny)
with {
      specbal = f2.xover1p1z : rms(window)+.000001, rms(window) 
       : ro.cross(2) : -;
      hp1p1z2(cf, x) = x : seq(i, 2, f2.hp1p1z(cf));
};

// Provides an index of how heterogeneous the state space of a signal is. 
// Inputs are "n" for number of states (must be provided as an argument at 
// compile-time); lower edge of the state space; upper edge of the state space; 
// memory of the analysis in seconds (hold-time and decay based on tau); input.
heterogeneity(n, l, h, t, in) = par(i, n,  region(l, h, n, i) ,
                                           t ,
                                           in : recurrence : ip.peak_hold(t) 
                                               : f2.lp1p(m2.div(1, t))) : m2.aad(n)
with {
      region(lower, upper, n, i) = lower + ((upper - lower) / n) * i ,
                                   lower + ((upper - lower) / n) * (i + 1);
};
// shortcut for a 10-region state space with [0; 1] range.
heterogeneity10(t, in) = heterogeneity(10, 0, 1, t, in);

// instantaneous amplitude
instant_amp(x) = f2.analytic(x) :  (_ <: *),
                                   (_ <: *) : + : sqrt;

// instantaneous frequency
instant_freq(x) = instant_ph(x) : m2.diff : /(2*ma.PI) : *(ma.SR);

// instantaneous phase
instant_ph(x) = f2.analytic(x) : atan2;

// loudness with a-weighted function
loudness(window, in) = in <:   peak_env(div(1, window)),
                               (spec_ten(window)*m2.ny : a_weighting) : *;

// detects lowest partial in a signal
lowest_partial(window, in) =   (_ <:   _,
                                       (   _, 
                                           in : lp1p1z2 <: _,
                                                           _) :    (specbal, 
                                                                   rms(window) 
                                   : m2.div : /(ma.SR) : *(window) 
                                       : f2.int_clip(0, 1) <: *)) 
                               ~ (*(m2.ny) : max(10))
with {
      specbal = f2.xover1p1z : rms(window), rms(window)+.000001 
       : ro.cross(2) : -;
      lp1p1z2(cf, x) = x : seq(i, 2, f2.lp1p1z(cf));
};

// noisiness index normalised for a 96kHz samplerate
noisiness(window, in) = spec_ten(window, in) : *(m2.ny) : max(1)
                           <:  m2.inv,
                               (   _, 
                                   in : zcr4 : m2.unit_log(10))
                               : m2.delta(1) : abs : f2.lp1p(window)
                                   : /(.266) <: * : min(1);

// infinitely fast attack and adjustable release
peak_env(release, in) = abs(in) :   max
                                    ~ *(release : m2.rt60);

// hold peak for a time specified in seconds
peak_hold(release, in) = in : ba.peakholder(release*ma.SR);

// detects lower and upper peaks and holds them for a time (in s) specified by 
// "release"
peaks(release, in) =   (   check_low 
                           ~ _) ,
                       (   check_high
                           ~ _)
with {
      check_low(s) =   (   in , 
                           s : <= <:   _ , 
                                       (   m2.div(1, release) ,
                                           _ : m2.ph : m2.diff : <(0)) : |) ,
                       s ,
                       in : select2;
      check_high(s) =  (   in , 
                           s : >= <:   _ , 
                                       (   m2.div(1, release) ,
                                           _ : m2.ph : m2.diff : <(0)) : |) ,
  		       s ,
                       in : select2;
};

// detects and integrates occurrences of signals within a specified range; 
// with exponential decay in s
recurrence(lower, upper, t, in) = in <: (  >(lower),
                                           <=(upper) : &) : fi.pole(m2.rt55(t));

// root mean square measurement using 1-pole lowpass for averaging
rms(window, in) = in <: * : f2.lp1p(window) : sqrt;

// RMS with fourth-order LP
rms4(window, in) = in <: * : seq(i, 4, f2.lp1p(window)) : sqrt;

/* The roughness measurement is based on amplitude transients in the 
 * 15-75Hz range. Theoretically, roughness decreases below 15Hz, 
 * peaks around 15-75Hz, and starts descresing above 75Hz to 
 * disappear around 150Hz and above. The "window" parameter may affect
 * the behaviour in the 0-15Hz range. A 1Hz window seems acceptable.
 */
roughness(window, in) = instant_amp(in) <: m2.delta(.001, .001) ,
                                           rms(1) : m2.div 
                           : rms4(75) : m2.delta(1/150, 1/150) 
                               : rms4(window)/.807242;

// spectral power (RMS) difference at a splitting point (Hz)
spec_bal(cf, window, in) =  cf,
                            in : f2.xover1p1z <:   rms(window) ,
                                                   rms(window) 
                                                       : ro.cross(2) : -;

// spectral power (RMS) difference at a splitting point (Hz) with
// Nth-order Butterworth filters xover
spec_balN(N, cf, window, in) = cf ,
                               in : f2.xover_butt(N) <:    rms(window) ,
                                                           rms(window) 
                                                               : ro.cross(2) 
                                                                   : -;

// spectral spread
spec_spr(window, in) = (   spec_ten(window, in)*m2.ny ,
                           10,
                           in) : f2.bpbi : ip.rms(window) ,
                                           (in : ip.rms(window)) 
                                               : m2.div : m2.complement;

// spectral tendency (equal-power spectral split-point)
spec_ten(window, in) =  (   (   _ ,
                                window ,
                                in : spec_bal) ,
                            (   window ,
                                in : rms) : m2.div : *(window)
                                   : f2.int_clip(0, 1) : pow(2)) 
                        ~ *(m2.ny);

// spectral tendency (equal-power spectral split-point) with nth-order
// Butterworth filters xover; improved response and stability through
// cubic nonlinearity
spec_tenN(N, window, in) = ((  _ ,
                               window ,
                               in : spec_balN(N)) ,
                            (  window ,
                               in : rms) : m2.div : pow(3) : 
                                   f2.int_eu_clip(0, 1, window) : pow(2))
                           ~ *(m2.ny);

// lite spectral tendency algorithm: no responsiveness parameter; less
// accurate (especially at low frequencies); 0-to-1 output.
spec_ten_lite(in) =    (   _,
                           in : f2.xover1p1zraw : ro.cross(2)
                               : balance : (   _ ,
                                               (in : rms) : m2.div)
                                                   : f2.integrator <: *)
                       ~ _
with {
      a0 = 100 / ma.SR;
      b1 = 1 - a0;
      rms(in) = in <: * : *(a0) :  +
                                   ~ *(b1) : sqrt;
      balance =    rms ,
                   rms : -;
};

// zero-crossing detection
zc(x) = x * x' : <(0);
                       
// zero-crossing rate
zcr(window, x) = zc(x) : f2.lp1p(window);

// zero-crossing rate with four cascaded 1plp for averaging 
zcr4(window, x) = zc(x) : seq(i, 4, f2.lp1p(window));
