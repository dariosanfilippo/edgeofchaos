// INFORMATION PROCESSING

ba = library("basics.lib");
fi = library("filters.lib");
f2 = library("filters2.lib");
ip = library("information.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
ro = library("routes.lib");
si = library("signals.lib");

// zero-crossing detection
zc(x) = x*x' : <(0);
                       
// zero-crossing rate
zcr(x, window) = zc(x) : f2.lp1p(_, window);

// infinitely fast attack and adjustable release
peak_env(in, release) = abs(in) :   max(_, _)
                                    ~ *(release : m2.rt60);

// hold peak for a time specified in seconds
peak_hold(in, release) = in : ba.peakholder(release*ma.SR);

// detects lower and upper peaks and holds them for a time (in s) specified by "release"
peaks(in, release) =   (   check_low 
                           ~ _),
                       (   check_high
                           ~ _)
with {
      check_low(s) =   (   in, 
                           s : <= <:   _, 
                                       (   1/release,
                                           _ : m2.ph : m2.diff : <(0)) : |),
                       s,
                       in : select2;
      check_high(s) =  (   in, 
                           s : >= <:   _, 
                                       (   1/release,
                                           _ : m2.ph : m2.diff : <(0)) : |),
  		       s,
                       in : select2;
};

// envelope following
env_fol(in, window) = in : abs : lp1p(_, window);

// root mean square measurement using lowpass
rms(in, window) = in <: * : f2.lp1p(_, window) : sqrt;

// RMS with fourth-order LP
rms4(in, window) = in <: * : seq(i, 4, _,
                                       window : f2.lp1p) : sqrt;

// spectral energy (RMS) difference at a splitting point (Hz)
spec_bal(in, cf, window) =  in ,
                            cf : f2.crossover <:   (   _ ,
                                                       window : rms : *(-1)) ,
                                                   (   _ ,
                                                       window : rms) : +;

// spectral tendency (weighted mean)
spec_ten(in, window) =  (   (   in ,
                                _ ,
                                window : spec_bal) ,
                            (   in ,
                                window : rms) :  m2.div : *(window) : /(ma.SR) : f2.clip_int(_, 0, 1)) 
                        ~ (pow(4) : *(m2.ny));

// noisiness
noisiness(in, window) = spec_ten(in, window) : *(m2.ny) <: (   in, 
                                                               _ : zcr : logscale),
                                                           (_ : ma.inv) : m2.delta : abs : f2.lp1p(_, window)
with {
      logscale(x) = log(x*(10-1)+1)/log(10);
};

// roughness
roughness(in, window) = in <:  (   (   rms4(_, 100),
                                       .01 : m2.delta : abs),
                                   window : f2.lp1p),
                               rms(_, window) : m2.div;

// spectral spread
spec_spr(in, window) = (   (in,
                           spec_ten(in, window)) : (   _, 
                                                       _, 
                                                       10) : f2.bpbi : (   _, 
                                                                           window) : ip.rms),
                       (in,
                       window : ip.rms) : m2.div : m2.complement;

// dynamicity index based on RMS, spectral tendency and noisiness
dynamicity(in, window) =   ((rms(in, 15) : logscale),
                           (spec_ten(in, 15) : logscale),
                           noisiness(in, 15)) : par(i, 3,  (_,
                                                           1/15) : m2.delta : abs : (  _,
                                                                                       window) : f2.lp1p) :> ma.tanh
with {
      logscale(x) = log(x*(10-1)+1)/log(10);
};

// detects and integrates occurrences of signals within a specified range; with exponential decay in s
recurrence(in, lower, upper, t) = in <: (   >(lower),
                                           <=(upper) : &) : fi.pole(m2.rt60(t));

// normalised average absolute deviation around the mean
aad(n) = si.bus(n) <:  (si.bus(n),
                       (si.bus(n) :> /(n) <: si.bus(n)) : ro.interleave(n, 2) : par(i, n, (- : abs)) :> _),
                       (si.bus(n) :> /(n)) : m2.div : /((n-1)*2);

// provides an index on how heterogeneous the state space of a signal is; inputs are n for number of states (must be provided as an argument), source signal, lower edge of the state space, upper edge of the state space, release time in s
heterogeneity(n) = si.bus(4) <: par(i, n, (    _,
                                               ((  _,
                                                   _,
                                                   n,
                                                   i) : region),
                                               _) : recurrence) : aad(n)
with {
      region(lower, upper, n, i) = lower+((upper-lower)/n)*i,
                                   lower+((upper-lower)/n)*(i+1);
};

// complexity index based on the edge of chaos of RMS, spectral tendency and noisiness
complexity(in, window) =   ((rms(in, 15) : logscale <: _,
                                                       _),
                           (spec_ten(in, 15) : logscale <: _,
                                                           _),
                           (noisiness(in, 15) <:   _,
                                                   _)) : par(i, 3, _,
                                                                   (   _,
                                                                       window : peaks : par(i, 2,  _,
                                                                                                   1/window : f2.lp1p))) : par(i, 3, ( _,
                                                                                                                                       _,
                                                                                                                                       _,
                                                                                                                                       window : heterogeneity(10))) : par(i, 3,    _,
                                                                                                                                                                                   window : m2.delta : abs : sqrt) :> ma.tanh
with {
      logscale(x) = log(x*(10-1)+1)/log(10);
};
