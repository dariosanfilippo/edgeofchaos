// INFORMATION PROCESSING

ba = library("basics.lib");
fi = library("filters.lib");
f2 = library("filters2.lib");
ip = library("information.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
ro = library("routes.lib");
si = library("signals.lib");

// zero-crossing detection
zc(x) = x*x' : <(0);
                       
// zero-crossing rate
zcr(x, window) = zc(x) : f2.lp1p(_, window);

// infinitely fast attack and adjustable release
peak_env(in, release) = abs(in) :   max(_, _)
                                    ~ *(release : m2.rt60);

// hold peak for a time specified in seconds
peak_hold(in, release) = in : ba.peakholder(release*ma.SR);

// envelope following
env_fol(in, window) = in : abs : lp1p(_, window);

// root mean square measurement using lowpass
rms(in, window) = in <: * : f2.lp1p(_, window) : sqrt;

// RMS with fourth-order LP
rms4(in, window) = in <: * : seq(i, 4, _,
                                       window : f2.lp1p) : sqrt;

// spectral energy (RMS) difference at a splitting point (Hz)
spec_bal(in, cf, window) =  in ,
                            cf : f2.crossover <:   (   _ ,
                                                       window : rms : *(-1)) ,
                                                   (   _ ,
                                                       window : rms) : +;

// spectral tendency (weighted mean)
spec_ten(in, window) =  (   (   in ,
                                _ ,
                                window : spec_bal) ,
                            (   in ,
                                window : rms) :  m2.div : *(window) : /(ma.SR) : f2.clip_int(_, 0, 1)) 
                        ~ (pow(4) : *(m2.ny));

// noisiness
noisiness(in, window) = spec_ten(in, window) <: (  in, 
                                                   _ : zcr : logscale),
                                                (_ : ma.inv) : m2.delta : abs : f2.lp1p(_, window)
with {
      logscale(x) = log(x*(10-1)+1)/log(10);
};

// roughness
roughness(in, window) = in <:  (   (   rms4(_, 100),
                                       .01 : m2.delta : abs),
                                   window : f2.lp1p),
                               rms(_, window) : m2.div;

// spectral spread
spec_spr(in, window) = (   (in,
                           spec_ten(in, window)) : (   _, 
                                                       _, 
                                                       10) : f2.bpbi : (   _, 
                                                                           window) : ip.rms),
                       (in,
                       window : ip.rms) : m2.div : m2.complement;

// dynamicity index based on RMS, spectral tendency and noisiness
dynamicity(in, window) =  (   (rms(in, 15) : logscale),
                       (spec_ten(in, 15) : logscale),
                       noisiness(in, 15)) : par(i, 3,  (_,
                                                       1/15) : m2.delta : abs : (  _,
                                                                                   window) : f2.lp1p) :> ma.tanh
with {
      logscale(x) = log(x*(10-1)+1)/log(10);
};

// detects and integrates occurrences of signals within a specified range; with exponential decay in s
recurrence(in, lower, upper, t) = in <: (   >(lower),
                                           <=(upper) : &) : fi.pole(m2.rt60(t));

// normalised average absolute deviation around the mean
aad(n) = si.bus(n) <:  (si.bus(n),
                       (si.bus(n) :> /(n) <: si.bus(n)) : ro.interleave(n, 2) : par(i, n, (- : abs)) :> _),
                       (si.bus(n) :> /(n)) : m2.div : /((n-1)*2);

// provides an index on how heterogeneous the state space of a signal is; n is the number of discrete states, upper and lower set the edges of the space, t is the release time
heterogeneity(in, n, lower, upper, t) = in <: par(i, n, _, 
                                                        lower+((upper-lower)/n)*i, 
                                                        lower+((upper-lower)/n)*(i+1)) : par(i, n,  (  _, 
                                                                                                       _,
                                                                                                       _,
                                                                                                       t : recurrence)) : aad(n);

// complexity
//complexity(in, window) = 
