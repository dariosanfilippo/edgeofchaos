/* Information processing algorithms in the time domain for low-level and high-level features.
 *
 * Copyright (c) 2019, Dario Sanfilippo <sanfilippo.dario at gmail dot com> 
 *
 * All rights reserved.
 */

au = library("auxiliary.lib");
ba = library("basics.lib");
fi = library("filters.lib");
f2 = library("filters2.lib");
ip = library("information.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
ro = library("routes.lib");
si = library("signals.lib");

// normalised average absolute deviation around the mean
aad(n) = si.bus(n) <:  (si.bus(n),
                       (si.bus(n) :> /(n) <: si.bus(n)) : ro.interleave(n, 2) 
                           : par(i, n, (- : abs)) :> _),
                       (si.bus(n) :> /(n)) : m2.div : /((n-1)*2);

// function for equal-loudness contour
a_weighting(f) = (12194^2*f^4)/((f^2+20.6^2)*sqrt((f^2+107.7^2)*(f^2+737.9^2))
                   *(f^2+12194^2));

// complexity index based on the edge of chaos of 
// RMS, spectral tendency and noisiness
complexity(window, in) =   (rms(15, in) : m2.unit_log(10)),
                           (spec_ten(15, in) : m2.unit_log(10)),
                           (noisiness(15, in) : m2.unit_log(10)) 
                               : par(i, 3, heterogeneity(10, 0, 1, window)) 
                                   : (  m2.div(_, t1),
                                        m2.div(_, t2),
                                        m2.div(_, t3)) : 
                                           par(i, 3, f2.lp1p(1/(window*2))) 
                                               : par(i, 3, m2.delta(   16, 
                                                                       window*2) 
                                                   : abs) 
                                                       :> f2.lp1p(1/(window*2)) 
                                                           : ma.tanh
with {
      t1 = ((rms(15, in) : m2.unit_log(10)) : ip.peaks(window) : ro.cross(2) 
               : -) : f2.lp1p(1/window) : m2.map_lin(.25, 1);
      t2 = ((spec_ten(15, in) : m2.unit_log(10)) : ip.peaks(window) 
               : ro.cross(2) : -) : f2.lp1p(1/window) : m2.map_lin(.25, 1);
      t3 = ((noisiness(15, in) : m2.unit_log(10)) : ip.peaks(window) 
               : ro.cross(2) : -) : f2.lp1p(1/window) : m2.map_lin(.25, 1);
};

// dynamicity index based on RMS, spectral tendency and noisiness
dynamicity(window, in) =   ((rms(15, in) : m2.unit_log(10)),
                           (spec_ten(15, in) : m2.unit_log(10)),
                           (noisiness(15, in) : m2.unit_log(10))) 
                               : par(i, 3, m2.delta(1/15, 1/15) : abs 
                                   : f2.lp1p(window)) :> ma.tanh;

// envelope following
env_fol(window, in) = in : abs : lp1p(window);

// Detects highest partial in a signal
highest_partial(window, in) =  (_ <:   _,
                                       (   _, 
                                           in : hp1p1z2 <: _,
                                                           _) :    (specbal, 
                                                                   rms(window) 
                                   : m2.div : /(ma.SR) : *(window) 
                                       : f2.int_clip(0, 1) <: *)) 
                               ~ *(m2.ny)
with {
      specbal = f2.xover1p1z : rms(window)+.000001, rms(window) 
       : ro.cross(2) : -;
      hp1p1z2(cf, x) = x : seq(i, 2, f2.hp1p1z(cf));
};

// provides an index of how heterogeneous the state space of a signal is; 
// inputs are n for number of states (must be provided as an argument), 
// source signal, lower edge of the state space, upper edge of the state space, 
// memory of the analysis in s
heterogeneity(n, l, h, t, in) = par(i, n,  region(l, h, n, i),
                                           t,
                                           in : recurrence : ip.peak_hold(t) 
                                               : f2.lp1p(1/t)) : aad(n)
with {
      region(lower, upper, n, i) = lower+((upper-lower)/n)*i,
                                   lower+((upper-lower)/n)*(i+1);
};

// instantaneous amplitude
instant_amp(x) = f2.analytic(x) :  (_ <: *),
                                   (_ <: *) : + : sqrt;

// instantaneous frequency
instant_freq(x) = instant_ph(x) : m2.diff : /(2*ma.PI) : *(ma.SR);

// instantaneous phase
instant_ph(x) = f2.analytic(x) : ro.cross(2) : atan2;

// loudness with a-weighted function
loudness(window, in) = in <:   peak_env(1/window),
                               (spec_ten(window)*m2.ny : a_weighting) : *;

// Detects lowest partial in a signal
lowest_partial(window, in) =   (_ <: _,
                                   (   _, 
                                       in : lp1p1z2 <: _,
                                                       _) :    (specbal, 
                                                               rms(window) 
                                   : m2.div : /(ma.SR) : *(window) 
                                       : f2.int_clip(0, 1) <: *)) 
                               ~ (*(m2.ny) : max(10))
with {
      specbal = f2.xover1p1z : rms(window), rms(window)+.000001 
       : ro.cross(2) : -;
      lp1p1z2(cf, x) = x : seq(i, 2, f2.lp1p1z(cf));
};

// noisiness index normalised for a 96kHz samplerate
noisiness(window, in) = spec_ten(window, in) : *(m2.ny) : max(1)
                           <:  m2.inv,
                               (   _, 
                                   in : zcr4 : m2.unit_log(10))
                               : m2.delta(1) : abs : f2.lp1p(window)
                                   : /(.266) <: * : min(1);

// infinitely fast attack and adjustable release
peak_env(release, in) = abs(in) :   max
                                    ~ *(release : m2.rt60);

// hold peak for a time specified in seconds
peak_hold(release, in) = in : ba.peakholder(release*ma.SR);

// detects lower and upper peaks and holds them for a time (in s) specified by 
// "release"
peaks(release, in) =   (   check_low 
                           ~ _),
                       (   check_high
                           ~ _)
with {
      check_low(s) =   (   in, 
                           s : <= <:   _, 
                                       (   1/release,
                                           _ : m2.ph : m2.diff : <(0)) : |),
                       s,
                       in : select2;
      check_high(s) =  (   in, 
                           s : >= <:   _, 
                                       (   1/release,
                                           _ : m2.ph : m2.diff : <(0)) : |),
  		       s,
                       in : select2;
};

// detects and integrates occurrences of signals within a specified range; 
// with exponential decay in s
recurrence(lower, upper, t, in) = in <: (  >(lower),
                                           <=(upper) : &) : fi.pole(m2.rt60(t));

// root mean square measurement using lowpass
rms(window, in) = in <: * : f2.lp1p(window) : sqrt;

// RMS with fourth-order LP
rms4(window, in) = in <: * : seq(i, 4, f2.lp1p(window)) : sqrt;

/* The roughness measurement is based on amplitude transients in the 
 * 15-75Hz range. Theoretically, roughness decreases below 15Hz, 
 * peaks around 15-75Hz, and starts descresing above 75Hz to 
 * disappear around 150Hz and above. The "window" parameter may affect
 * the behaviour in the 0-15Hz range. A 1Hz window seems acceptable.
 */
roughness(window, in) = instant_amp(in) <: m2.delta(.001, .001),
                                           rms(1) : m2.div 
                           : rms4(75) : m2.delta(1/150, 1/150) 
                               : rms4(window)/.807242;

// spectral power (RMS) difference at a splitting point (Hz)
spec_bal(cf, window, in) =  cf,
                            in : f2.xover1p1z <:   rms(window),
                                                   rms(window) 
                                                       : ro.cross(2) : -;
// spectral spread
spec_spr(window, in) = (   spec_ten(window, in)*m2.ny,
                           10,
                           in) : f2.bpbi : ip.rms(window),
                                           (in : ip.rms(window)) 
                                               : m2.div : m2.complement;

// spectral tendency (equal-power spectral split-point)
spec_ten(window, in) =  (   (   _ ,
                                window,
                                in : spec_bal),
                            (   window,
                                in : rms) : m2.div : *(window) : /(ma.SR) 
                                   : f2.int_clip(0, 1) : pow(4)) 
                        ~ *(m2.ny);

// lite spectral tendency algorithm: no responsiveness parameter; less
// accurate (especially at low frequencies); 0-to-1 output.
spec_ten_lite(in) =    (   _,
                           in : f2.xover1p1zraw : ro.cross(2)
                               : balance : (_,
                                           (in : rms) : m2.div)
                                               : integrator <: *)
                       ~ _
with {
      rms(in) = in <: * : *(.001) : +
                                   ~ *(.999) : sqrt;
      balance =    rms,
                   rms : -;
      integrator = _/ma.SR :  +
                              ~ _; 
};

// zero-crossing detection
zc(x) = x*x' : <(0);
                       
// zero-crossing rate
zcr(window, x) = zc(x) : f2.lp1p(window);

// zero-crossing rate with four cascaded 1plp for averaging 
zcr4(window, x) = zc(x) : seq(i, 4, f2.lp1p(window));
