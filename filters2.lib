ba = library("basics.lib");
fi = library("filters.lib");
f2 = library("filters2.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
st = library("stability.lib");

// FILTERS

// sample-and-hold signals that have remained constant for t seconds
sah_dc(in, t) =    m2.delta(in, t) : ==(0),
                   in : ba.sAndH;

// sample-and-hold signals that have changed in direction
sah_inv(in) = m2.diff(in) : >(0) <:    (_,
                                        _' : !=),
                                       in : ba.sAndH;

// bounded integrator
int_clip(in, lower, upper) =    (_ ,
                                in : + : st.clip(_, lower, upper)) 
                                ~ _;

// classic 1-pole lowpass
lp1p(in, cf) = in*a0 : + ~ *(b1)
with {
      a0 = 1-abs(b1);
      b1 = exp(m2.w(cf)*(-1));
};

// classic 1-pole highpass
hp1p(in, cf) = in*a0 : + ~ *(b1)
with {
      a0 = 1-abs(b1);
      b1 = exp((.5-cf/ma.SR)*-2*ma.PI)*(-1);
};


// 1-pole lowpass based on naive integration
lp1pint(in, cf) =   (in ,
                    _ : + : *(m2.w(cf) : st.clip(_, 0, 2)) : fi.pole(1)
                    ) ~ *(-1);

// 1-pole highpass based on naive integration
hp1pint(in, cf) = in-lp1pint(in, cf);

// 1-pole-1-zero lowpass
lp1p1z(in, cf) =    in*a0 ,
                    in'*a0*a1 : + : +
                                    ~ *(b1)
with {
    a0 = (1-b1)/2;
    a1 = 1;
    b1 =    (1-sin(m2.w(cf))) ,
            cos(m2.w(cf)) : m2.div;
};

// 1-pole-1-zero highpass
hp1p1z(in, cf) =    in*a0 ,
                    in'*a0*a1 : + : +
                                    ~ *(b1)
with {
    a0 = (1+b1)/2;
    a1 = -1;
    b1 =    (1-sin(m2.w(cf))) ,
            cos(m2.w(cf)) : m2.div;
};

// 1p1z lowpass BLTI
lpblti(in, cf) =   state 
                   ~ _ :   ! , 
                           _
with {
      g = tan(m2.w(cf)/2)/(1+tan(m2.w(cf)/2));
      state(s) = y + v, y
      with { 
           v = (in - s) * g;
           y = (v + s);
      };
};

// 1p1z highpass BLTI
hpblti(in, cf) =   in ,
                   (   in ,
                       cf : lpblti) : -;

// 1p1z allpass BLTI
apblti(in, cf) = ( in ,
                   cf) <:  lpblti ,
                           hpblti : -;

// spectrum splitter
crossover(in, cf) = lp1p1z(in, cf) ,
                    hp1p1z(in, cf);

// biquad section
biquad(x, a0, a1, a2, b1, b2) = fir : + ~ iir
with {
      fir = a0*x+a1*x'+a2*x'';
      iir(fb) = -b1*fb-b2*fb';
};

// biquad lowpass
lpbi(in, cf) = biquad(in, a0, a1, a2, b1, b2)
with {
      cf1 = st.clip(cf, 5, m2.ny-5);
      q1 = .707;
      alpha = sin(m2.w(cf1))/(2*q1);
      norm = 1+alpha;
      a0 = ((1-cos(m2.w(cf1)))/2)/norm;
      a1 = 1-cos(m2.w(cf1))/norm;
      a2 = ((1-cos(m2.w(cf1)))/2)/norm;
      b1 = cos(m2.w(cf1))*-2/norm;
      b2 = (1-alpha)/norm;
};

// biquad highpass
hpbi(in, cf) = biquad(in, a0, a1, a2, b1, b2)
with {
      cf1 = st.clip(cf, 5, m2.ny-5);
      q1 = .707;
      alpha = sin(m2.w(cf1))/(2*q1);
      norm = 1+alpha;
      a0 = ((1+cos(m2.w(cf1)))/2)/norm;
      a1 = -1*(1+cos(m2.w(cf1)))/norm;
      a2 = ((1+cos(m2.w(cf1)))/2)/norm;
      b1 = cos(m2.w(cf1))*-2/norm;
      b2 = (1-alpha)/norm;
};

// biquad bandpass
bpbi(in, cf, q) = biquad(in, a0, a1, a2, b1, b2)
with {
      cf1 = st.clip(cf, 5, m2.ny-5);
      q1 = max(q, .001);
      alpha = sin(m2.w(cf1))/(2*q1);
      norm = 1+alpha;
      a0 = alpha/norm;
      a1 = 0;
      a2 = -alpha/norm;
      b1 = cos(m2.w(cf1))*-2/norm;
      b2 = (1-alpha)/norm;
};

// biquad bandstop
bsbi(in, cf, q) = biquad(in, a0, a1, a2, b1, b2)
with {
      cf1 = st.clip(cf, 5, m2.ny-5);
      q1 = max(q, .001);
      alpha = sin(m2.w(cf1))/(2*q1);
      norm = 1+alpha;
      a0 = 1/norm;
      a1 = -1*cos(m2.w(cf1))*2/norm;
      a2 = 1/norm;
      b1 = -1*cos(m2.w(cf1))*2/norm;
      b2 = (1-alpha)/norm;
};

// biquad allpass
apbi(in, cf) = biquad(in, a0, a1, a2, b1, b2)
with {
      cf1 = st.clip(cf, 5, m2.ny-5);
      q1 = .707;
      alpha = sin(m2.w(cf1))/(2*q1);
      norm = 1+alpha;
      a0 = (1-alpha)/norm;
      a1 = -1*cos(m2.w(cf1))*2/norm;
      a2 = (1+alpha)/norm;
      b1 = -1*cos(m2.w(cf1))*2/norm;
      b2 = (1-alpha)/norm;
};
