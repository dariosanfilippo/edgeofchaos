/* Audio processing functions.
 *
 * Copyright (c) 2019, Dario Sanfilippo <sanfilippo.dario at gmail dot com> 
 *
 * All rights reserved.
 */

au = library("auxiliary.lib");
ba = library("basics.lib");
de = library("delays.lib");
d2 = library("delays2.lib");
fi = library("filters.lib");
f2 = library("filters2.lib");
ip = library("information.lib");
op = library("outformation.lib");
os = library("oscillators.lib");
o2 = library("oscillators2.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
ro = library("routes.lib");
si = library("signals.lib");
st = library("stability.lib");

// granulator based on DL with overlap-add to 1 but non-homogeneous windowing 
// and transposition
grains_dl_nhw(size, pitch, rate, position, exponent, x) = head1+head2
with {
      s = size*ma.SR : m2.round_pow2 : /(ma.SR);
      sah(t, in) = (m2.diff(t) : <(0)),
                   in : ba.sAndH;
      ph0 = o2.ph(rate, 0);
      ph1 = ph0 : pow(exponent) : ma.decimal;
      ph2 = ph1+.5 : ma.decimal;
      w1 = ph1 : m2.window_hann;
      w2 = ph2 : m2.window_hann;
      head1 = d2.del_pol(size, del1, x)*w1
      with {
       del1 = sah(ph1, position)+shift1 : m2.wrap(0, s);
       shift1 = (1-sah(ph1, pitch))*(  1,
                                       sah(ph1, rate) : m2.div)*ph1;
      };
      head2 = d2.del_pol(size, del2, x)*w2
      with {
       del2 = sah(ph2, position)+shift2 : m2.wrap(0, s);
       shift2 = (1-sah(ph2, pitch))*(  1,
                                       sah(ph2, rate) : m2.div)*ph2;
      };
};

// DL-based ZC granulator
grains_dl_zc(voices, size1) = par(i, voices,    loop
                                                ~ _) :> /(voices)
with {
    loop(out, pitch1, rate, position1, input) =
        (ba.sAndH(trigger(out), zc_index(position, input, out)) 
            + shift(trigger(out))) : m2.wrap(0, size) - 1,
        input : grain
    with {
        trigger(y) =    loop
                        ~ _
        with {
            loop(ready) =   (ip.zc(y)),
                            (m2.line_reset(ba.sAndH(1-1' + ready, rate), ready) 
                                : >=(1)) : &;
            };
        shift(reset) = m2.div((1 - pitch), rate) *
            m2.line_reset(rate, reset) * ma.SR;
        zc_index(recall, x, y) = index - ba.if( m2.diff(y) : >=(0),
                                                zc_up,
                                                zc_down) : m2.wrap(0, size)
        with {
            zc_up = ba.sAndH(store, index), recall : dl
            with {
                store = ip.zc(x),
                        (m2.diff(x) : >(0)) : &;
            };
            zc_down = ba.sAndH(store, index), recall : dl
            with { 
                store = ip.zc(x),
                        (m2.diff(x) : <(0)) : &;
            };
        };
        size = size1 * ma.SR : m2.round_pow2;
        pitch = ba.sAndH(trigger(out), pitch1);
        position = position1 * ma.SR : m2.wrap(0, size);
        index = ba.period(size);
        grain(del, in) = de.fdelayltv(4, size, del, in);
        dl(in, del) = in : de.delay(size, del);
    };
};

// table-based ZC granulator, i.e., discontinuities are handled through ZC 
// detection
grains_zc(position, g_size, x) =    grains
                                    ~ _
with {
    s = 768000;
    l = g_size*ma.SR;
    p = position*ma.SR;
    input = x;
    rec_index = %(s) ~ +(1);
    grains(fb) =    int(s),
                    0.0,
                    int(rec_index),
                    input,
                    int(read_frame(fb) : %(s)) : rwtable
    with {
        sel_zc(x) = ba.if(  (m2.diff(x) : >(0)),
                            zc_up_index,
                            zc_down_index);
        frame(start) =  %(dur) ~ +(1)
        with {
            dur = zc_index(start+l)-start : max(2);
        };
        read_frame(out) = (frame <: _,
                                    (==(0),
                                    sel_zc(out) : ba.sAndH)) ~ (!, _) : +;
        zc_up =     (ip.zc(input),
                    (m2.diff(input) : >(0)) : &);
        zc_down =   (ip.zc(input),
                    (m2.diff(input) : <(0)) : &);
        zc_index(x) =   int(s),
                        0.0,
                        int(rec_index),
                        (   ip.zc(input),
                            rec_index : ba.sAndH),
                        int(x : %(s)) : rwtable;
        zc_up_index =   int(s),
                        0.0,
                        int(rec_index),
                        (   zc_up,
                            rec_index : ba.sAndH),
                        int(p : %(s)) : rwtable;
        zc_down_index = int(s),
                        0.0,
                        int(rec_index),
                        (   zc_down,
                            rec_index : ba.sAndH),
                        int(p : %(s)) : rwtable;
    };
};

// real-time pitch-shifter with 4th-order pol. delay lines
pitch_shift(buff_size, frame, factor, x) = d2.del_pol(buff_size, del1, x)*w1, 
                                           d2.del_pol(buff_size, del2, x)*w2 
                                               :> _
with {
      frame_1 = frame : abs;
      rate =   1,
               frame_1 : m2.div;
      shift = (1-factor)*frame_1;
      offset = ba.if(  shift < 0,
                       -shift,
                       0);
      limit = buff_size*ma.SR : m2.round_pow2 : /(ma.SR); 
      ph1 = m2.ph(rate, 0);
      ph2 = ph1 : +(.5) : ma.decimal;
      w1 = m2.window_hann(ph1); 
      w2 = m2.window_hann(ph2);
      del1 = shift*ph1+offset : m2.wrap(0, limit);
      del2 = shift*ph2+offset : m2.wrap(0, limit); 
};

// pole modulation of normalised 1-pole systems, hence oscillating
// between low-pass and high-pass. The modulator has a shaping parameter
// going from -1 to 1 where the we have square at -1, sine at 0, pulses at 1
pole_mod(rate, shaping, x) = x*norm : fi.pole(mod)
with {
      norm = 1-abs(mod);
      mod = os.oscsin(rate) <: ma.signum,
                               (abs : pow(shaping1)) : *
      with {
       shaping1 = pow(1000, st.clip(-1, 1, shaping));
      };
};

// Feedback delay network reverb with non-transposing variable DL;
// n must be a power of 2; FB coeffients are stable up to a magnitude of 1
rev_fdn_smo(n, max_size, it, size, fb_coeff, cf, in) = 
      (summing : delays : filters : matrix : fb) 
      ~ si.bus(n) :> /(n)
with {
      st = 1/sqrt(n);
      summing = par(i, n, +(in));
      delays = par(i, n,   max_size, 
                           it,
                           (size : m2.prime_base_pow(i+1)),
                           _) : par(i, n, d2.del_smo);
      filters = par(i, n, f2.lp1p(cf));
      matrix = ro.hadamard(n);
      fb = par(i, n, *(fb_coeff*st));
};

// Feedback delay network reverb with variable DL;
// n must be a power of 2; FB coeffients are stable up to a magnitude of 1
rev_fdn_pol(n, max_size, size, fb_coeff, cf, in) = 
      (summing : delays : filters : matrix : fb) 
      ~ si.bus(n) :> /(n)
with {
      st = 1/sqrt(n);
      summing = par(i, n, +(in));
      delays = par(i, n,   max_size,
                           (size : m2.prime_base_pow(i+1)),
                           _) : par(i, n, d2.del_pol);
      filters = par(i, n, f2.lp1p(cf));
      matrix = ro.hadamard(n);
      fb = par(i, n, *(fb_coeff*st));
};

// sampler with speed, frame size, and buffer position control
sampler(buff_size, frame, position, factor, x) = d2.del_pol(buff_size, del, x)
with {
      frame_1 = frame : abs : f2.lp1p(20);
      position_1 = position : f2.lp1p(20);
      rate =   1,
               frame_1 : m2.div;
      shift =  (1-factor)*frame_1;
      offset = ba.if(  shift < 0,
                       -shift,
                       0);
      limit = buff_size*ma.SR : m2.round_pow2 : /(ma.SR);
      ph = m2.ph(rate, 0);
      del = shift*ph+offset+position_1 : m2.wrap(0, limit);
}; 

// single-sideband modulation (positive side)
ssbm(shift, in) =  f2.analytic(in),
                   o2.osc_quad(shift) : si.cmul :  _,
                                                   !;

// real-time time-stretcher with delay lines
time_stretch(buff_size, frame, factor, x) =    d2.del_pol(buff_size, del1, x)*w1, 
                                               d2.del_pol(buff_size, del2, x)*w2 
                                                   :> _
with {
      buff = buff_size*ma.SR : m2.round_pow2 : /(ma.SR);
      position = m2.ph((1-factor)/buff, 0)*buff;
      frame_1 = frame : abs;
      rate =   1,
               frame_1 : m2.div;
      ph1 = m2.ph(rate, 0);
      ph2 = ph1 : +(.5) : ma.decimal;
      w1 = m2.window_hann(ph1);
      w2 = m2.window_hann(ph2);
      del1 = position : ba.sAndH(ph1 : m2.diff : <(0));
      del2 = position : ba.sAndH(ph2 : m2.diff : <(0));
};

// time-variant transfer function
tvtf(s, zcr, f, in) = d2.del_pol(s, in1, f1)
with {
      in1 = in : m2.wrap(-1, 1) : m2.uni : *(s1);
      s1 = s*ma.SR : m2.round_pow2 : /(ma.SR);
      f1 = f : seq(i, 4, f2.lp1p(zcr/s1)) : st.dyn_norm_peak(1/s1, 1);
};



