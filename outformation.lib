// =============================================================================
// ========== outformation.lib =================================================
// =============================================================================
// 
// Library of functions for the transformation of audio signals. The
// library includes standard techniques such as frequency shifting, artificial 
// reverberators with different delay line schemes, and other modulations, as 
// well as original techniques such as windowless granular processing based on
// zero-crossing detection.
//
// The environment prefix is "op".
// 
// List of functions:
//
//    grains_dl_nhw,
//    grains_dl_zc,
//    grains_zc,
//    pitch_shift,
//    pole_mod,
//    rev_fdn_smo,
//    rev_fdn_pol,
//    sampler,
//    ssbm,
//    time_stretch,
//    tvtf.
//
// Copyright (c) 2019-2020, Dario Sanfilippo <sanfilippo.dario at gmail dot com>
// All rights reserved.

declare name "Outformation Library";
declare author "Dario Sanfilippo";
declare copyright "Copyright (c) 2019-2020, Dario Sanfilippo <sanfilippo.dario
      at gmail dot com>";
declare version "1.0.0";
declare license "GPLv2.0";

au = library("auxiliary.lib");
ba = library("basics.lib");
de = library("delays.lib");
d2 = library("delays2.lib");
fi = library("filters.lib");
f2 = library("filters2.lib");
ip = library("information.lib");
op = library("outformation.lib");
os = library("oscillators.lib");
o2 = library("oscillators2.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
ro = library("routes.lib");
si = library("signals.lib");
st = library("stability.lib");

// granulator based on DL with overlap-add to 1 but non-homogeneous windowing 
// and transposition
grains_dl_nhw(size, pitch, rate, position, exponent, x) = head1 + head2
      with {
           s = size * ma.SR : m2.round_pow2 / ma.SR;
           sah(t, in) =    (m2.diff(t) < 0) ,
                           in : ba.sAndH;
           ph0 = o2.ph(rate, 0);
           ph1 = pow(ph0, exponent) : ma.decimal;
           ph2 = ph1 + .5 : ma.decimal;
           w1 = m2.window_hann(ph1);
           w2 = m2.window_hann(ph2);
           head1 = d2.del_pol(s, del1, x) * w1
               with {
                   del1 = sah(ph1, position) + shift1 : m2.wrap(0, s);
                   shift1 = (1 - sah(ph1, pitch)) * 
                       (   1,
                           sah(ph1, rate) : m2.div) * ph1;
               };
           head2 = d2.del_pol(s, del2, x) * w2
               with {
                   del2 = sah(ph2, position) + shift2 : m2.wrap(0, s);
                   shift2 = (1 - sah(ph2, pitch)) * 
                       (   1,
                           sah(ph2, rate) : m2.div) * ph2;
               };
      };

// DL-based ZC granulator
grains_dl_zc(voices, size1) = par(i, voices,    loop
                                                ~ _) :> / (voices)
with {
    loop(out, pitch1, rate1, position1, input) =
        (ba.sAndH(trigger(out), zc_index(position, input, out)) 
            + shift(trigger(out))) : m2.wrap(0, size) - 1 ,
        input : grain
    with {
        trigger(y) =    loop
                        ~ _
        with {
            loop(ready) =   
               ip.zc(y) ,
               (m2.line_reset(ba.sAndH(au.dirac + ready, rate), ready) >= 1) : 
                   &;
        };
        shift(reset) = m2.div((1 - pitch), rate) *
            m2.line_reset(rate, reset) * ma.SR;
        zc_index(recall, x, y) = 
           index - m2.if(m2.diff(y) >= 0, zc_up, zc_down) : m2.wrap(0, size)
        with {
            zc_up = ba.sAndH(store, index), recall : dl
            with {
                store = ip.zc(x) ,
                        (m2.diff(x) > 0) : &;
            };
            zc_down = ba.sAndH(store, index), recall : dl
            with { 
                store = ip.zc(x) ,
                        (m2.diff(x) < 0) : &;
            };
        };
        size = size1 * ma.SR : m2.round_pow2;
        rate = abs(rate1);
        pitch = ba.sAndH(trigger(out), pitch1);
        position = position1 * ma.SR : m2.wrap(0, size);
        index = ba.period(size);
        grain(del, in) = de.fdelayltv(4, size, del, in);
        dl(in, del) = de.delay(size, del, in);
    };
};

// -----------------------------------------------------------------------------
// table-based ZC granulator, i.e., discontinuities are handled through ZC 
// detection
grains_zc(position, g_size, x) =    grains
                                    ~ _
      with {
           s = 768000;
           l = g_size * ma.SR;
           p = position * ma.SR;
           input = x;
           rec_index = % (s) 
                       ~ + (1);
           grains(fb) =    int(s) ,
                           0.0 ,
                           int(rec_index) ,
                           input ,
                           int(read_frame(fb) % s) : rwtable
           with {
               sel_zc(x) = 
                   ba.if(m2.diff(x) > 0, zc_up_index, zc_down_index);
               frame(start) =  % (dur) 
                               ~ + (1)
               with {
                   dur = zc_index(start + l) - start : max(2);
               };
               read_frame(out) = (frame <: _ ,
                                           (== (0) ,
                                           sel_zc(out) : ba.sAndH)) 
                                           ~ ( ! , 
                                               _) : +;
               zc_up = (ip.zc(input) ,
                       (m2.diff(input) > 0) : &);
               zc_down =   (ip.zc(input) ,
                           (m2.diff(input) < 0) : &);
               zc_index(x) =   int(s) ,
                               0.0 ,
                               int(rec_index) ,
                               (   ip.zc(input) ,
                                   rec_index : ba.sAndH) ,
                               int(x % s) : rwtable;
               zc_up_index =   int(s) ,
                               0.0 ,
                               int(rec_index) ,
                               (   zc_up ,
                                   rec_index : ba.sAndH) ,
                               int(p % s) : rwtable;
               zc_down_index = int(s) ,
                               0.0 ,
                               int(rec_index) ,
                               (   zc_down ,
                                   rec_index : ba.sAndH) ,
                               int(p % s) : rwtable;
           };
      };

// real-time pitch-shifter with 4th-order pol. delay lines
pitch_shift(buff_size, frame, factor, x) = 
      d2.del_pol(buff_size, del1, x) * w1 , 
      d2.del_pol(buff_size, del2, x) * w2 :> _
      with {
           frame_1 = frame : abs;
           rate =  1 ,
                   frame_1 : m2.div;
           shift = (1 - factor) * frame_1;
           offset = m2.if(shift < 0, -shift, 0);
           limit = m2.round_pow2(buff_size * ma.SR) / ma.SR; 
           ph1 = m2.ph(rate, 0);
           ph2 = ma.decimal(ph1 + .5);
           w1 = m2.window_hann(ph1); 
           w2 = m2.window_hann(ph2);
           del1 = shift * ph1 + offset : m2.wrap(0, limit);
           del2 = shift * ph2 + offset : m2.wrap(0, limit); 
      };

// pole modulation of normalised 1-pole systems, hence oscillating
// between low-pass and high-pass. The modulator has a shaping parameter
// going from -1 to 1 where the we have square at -1, sine at 0, pulses at 1
pole_mod(rate, shaping, x) = x * norm : fi.pole(mod)
      with {
           norm = 1 - abs(mod);
           mod = os.oscsin(rate) <: ma.signum * (abs : pow(shaping1))
           with {
               shaping1 = pow(1000, st.clip(-1, 1, shaping));
           };
      };

// Feedback delay network reverb with non-transposing variable DL;
// n must be a power of 2; FB coeffients are stable up to a magnitude of 1
rev_fdn_smo(n, max_size, it, size, fb_coeff, cf, in) = 
      (summing : delays : filters : matrix : fb) 
      ~ si.bus(n) :> / (n)
      with {
           st = 1 / sqrt(n);
           summing = par(i, n, + (in));
           delays = par(i, n,  max_size , 
                               it ,
                               (   size : m2.prime_base_pow(i + 1)) ,
                                   _) : par(i, n, d2.del_smo);
           filters = par(i, n, f2.lp1p(cf));
           matrix = ro.hadamard(n);
           fb = par(i, n, * (fb_coeff * st));
      };

// Feedback delay network reverb with variable DL;
// n must be a power of 2; FB coeffients are stable up to a magnitude of 1
rev_fdn_pol(n, max_size, size, fb_coeff, cf, in) = 
      (summing : delays : filters : matrix : fb) 
      ~ si.bus(n) :> /(n)
with {
      st = 1 / sqrt(n);
      summing = par(i, n, + (in));
      delays = par(i, n,   max_size ,
                           (   size : m2.prime_base_pow(i + 1)),
                               _) : par(i, n, d2.del_pol);
      filters = par(i, n, f2.lp1p(cf));
      matrix = ro.hadamard(n);
      fb = par(i, n, * (fb_coeff * st));
};

// sampler with speed, frame size, and buffer position control
sampler(buff_size, frame, position, factor, x) = d2.del_pol(buff_size, del, x)
      with {
           frame_1 = abs(frame) : f2.lp1p(20);
           position_1 = position : f2.lp1p(20);
           rate = m2.div(1, frame_1);
           shift = (1 - factor) * frame_1;
           offset = m2.if(shift < 0, -shift, 0);
           limit = buff_size * ma.SR : m2.round_pow2 / ma.SR;
           ph = m2.ph(rate, 0);
           del = shift * ph + offset+position_1 : m2.wrap(0, limit);
      }; 

// single-sideband modulation (positive side)
ssbm(shift, in) =  f2.analytic(in) ,
                   o2.osc_quad(shift) : si.cmul :  _ ,
                                                   !;

// real-time time-stretcher with delay lines
time_stretch(buff_size, frame, factor, x) =    
      d2.del_pol(buff_size, del1, x) * w1 , 
      d2.del_pol(buff_size, del2, x) * w2 :> _
      with {
           buff = buff_size * ma.SR : m2.round_pow2 / ma.SR;
           position = m2.ph((1 - factor) / buff, 0) * buff;
           frame_1 = abs(frame);
           rate = m2.div(1, frame_1);
           ph1 = m2.ph(rate, 0);
           ph2 = ma.decimal(ph1 + .5);
           w1 = m2.window_hann(ph1);
           w2 = m2.window_hann(ph2);
           del1 = position : ba.sAndH(m2.diff(ph1) < 0);
           del2 = position : ba.sAndH(m2.diff(ph2) < 0);
      };

// time-variant transfer function
tvtf(s, zcr, f, in) = d2.del_pol(s, in1, f1)
      with {
           in1 = in : m2.wrap(-1, 1) : m2.uni * s1;
           s1 = s * ma.SR : m2.round_pow2 / ma.SR;
           f1 = f : seq(i, 4, f2.lp1p(zcr / s1)) : st.dyn_norm_peak(1 / s1, 1);
      };



