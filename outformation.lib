// AUDIO PROCESSING LIBRARY

au = library("auxiliary.lib");
ba = library("basics.lib");
de = library("delays.lib");
d2 = library("delays2.lib");
f2 = library("filters2.lib");
ip = library("information.lib");
op = library("outformation.lib");
o2 = library("oscillators2.lib");
ma = library("maths.lib");
m2 = library("maths2.lib");
ro = library("routes.lib");
si = library("signals.lib");
st = library("stability.lib");

// real-time pitch-shifter with 6th-order pol. delay lines
pitch_shift(factor, frame, buff_size, x) = d2.del_pol(del1, buff_size, x)*w1, 
                                           d2.del_pol(del2, buff_size, x)*w2 :> _
with {
      frame_1 = frame : abs;
      rate =   1,
               frame_1 : m2.div;
      shift = (1-factor)*frame_1;
      offset = ba.if(  shift < 0,
                       -shift,
                       0);
      limit = buff_size*ma.SR : m2.round_pow2 : /(ma.SR); 
      ph1 = m2.ph(rate, 0);
      ph2 = ph1 : +(.5) : ma.decimal;
      w1 = m2.window_hann(ph1); 
      w2 = m2.window_hann(ph2);
      del1 = shift*ph1+offset : m2.wrap(0, limit);
      del2 = shift*ph2+offset : m2.wrap(0, limit); 
};

// real-time time-stretcher with 6th-order pol. delay lines
time_stretch(factor, frame, buff_size, x) =    d2.del_pol(del1, buff_size, x)*w1, 
                                               d2.del_pol(del2, buff_size, x)*w2 :> _
with {
      buff = buff_size*ma.SR : m2.round_pow2 : /(ma.SR);
      position = m2.ph((1-factor)/buff, 0)*buff;
      frame_1 = frame : abs;
      rate =   1,
               frame_1 : m2.div;
      ph1 = m2.ph(rate, 0);
      ph2 = ph1 : +(.5) : ma.decimal;
      w1 = m2.window_hann(ph1);
      w2 = m2.window_hann(ph2);
      del1 = position : ba.sAndH(ph1 : m2.diff : <(0));
      del2 = position : ba.sAndH(ph2 : m2.diff : <(0));
};

// granulator based on DL with overlap-add to 1 but non-homogeneous windowing

grains_dl_nhw(size, pitch, rate, position, exponent, x) = head1+head2
with {
      s = size*ma.SR : m2.round_pow2 : /(ma.SR);
      sah(t, in) = (m2.diff(t) : <(0)),
                   in : ba.sAndH;
      ph0 = o2.ph(rate, 0);
      ph1 = ph0+.05 : ma.decimal;
      ph2 = ph0 : pow(exponent);
      ph3 = ph2+.05 : ma.decimal;
      head1 = d2.del_pol(size, del1, x)*w1
      with {
       w1 = ph2 : m2.window_hann;
       del1 = sah(ph0, position)+shift1 : m2.wrap(0, s);
       shift1 = (1-sah(ph0, pitch))*(  1,
                                       sah(ph0, rate): m2.div)*ph0;
      };
      head2 = d2.del_pol(size, del2, x)*w2
      with {
       w2 = ph3: m2.window_hann;
       del2 = sah(ph1, position)+shift2 : m2.wrap(0, s);
       shift2 = (1-sah(ph1, pitch))*(  1,
                                       sah(ph1, rate): m2.div)*ph1;
      };
};

// table-based ZC granulator, i.e., discontinuities are handled through ZC detection
grains_zc(position, g_size, x) =    grains
                                    ~ _
with {
    s = 768000;
    l = g_size*ma.SR;
    p = position*ma.SR;
    input = x;
    rec_index = %(s) ~ +(1);
    grains(fb) =    int(s),
                    0.0,
                    int(rec_index),
                    input,
                    int(read_frame(fb) : %(s)) : rwtable
    with {
        sel_zc(x) = ba.if(  (m2.diff(x) : >(0)),
                            zc_up_index,
                            zc_down_index);
        frame(start) =  %(dur) ~ +(1)
        with {
            dur = zc_index(start+l)-start : max(2);
        };
        read_frame(out) = (frame <: _,
                                    (==(0),
                                    sel_zc(out) : ba.sAndH)) ~ (!, _) : +;
        zc_up =     (ip.zc(input),
                    (m2.diff(input) : >(0)) : &);
        zc_down =   (ip.zc(input),
                    (m2.diff(input) : <(0)) : &);
        zc_index(x) =   int(s),
                        0.0,
                        int(rec_index),
                        (   ip.zc(input),
                            rec_index : ba.sAndH),
                        int(x : %(s)) : rwtable;
        zc_up_index =   int(s),
                        0.0,
                        int(rec_index),
                        (   zc_up,
                            rec_index : ba.sAndH),
                        int(p : %(s)) : rwtable;
        zc_down_index = int(s),
                        0.0,
                        int(rec_index),
                        (   zc_down,
                            rec_index : ba.sAndH),
                        int(p : %(s)) : rwtable;
    };
};

// DL-based ZC granulator
grains_dl_zc(n, s) = par(i, n, grain) :> /(n)
with {
      size = s*ma.SR : m2.round_pow2;
      index = ba.period(size);
      grain(pitch, rate, pos, input) = (input,
                                       (   input,
                                               _,
                                            pitch,
                                            (rate : abs),
                                            pos : read_grain) : dl_pol)
                                       ~ _;
      read_grain(input, fb, pitch, rate, pos) = (  trigger,
                                                   index : ba.sAndH),
                                                (  trigger,
                                                   (   input,
                                                       pos,
                                                       fb : zc_index) : ba.sAndH) : - : +(shift) : m2.wrap(0, size)
      with {
       zc_index(input, position, direction) = ba.if((m2.diff(direction) : >=(0)),
                                                    (  input,
                                                       p : zc_index_up),
                                                    (  input,
                                                       p : zc_index_down)) : +(1)
       with {
           p = position*ma.SR : m2.wrap(0, size);
       };
       trigger =   check
                   ~ _
       with {
           check(ready) =  (fb : ip.zc),
                           (m2.line_reset(rate, ready) : >=(1)) : &;
       };
      shift =  (1,
               (   trigger,
                   pitch : ba.sAndH) : -)*(    1,
                                               (trigger,
                                               rate : ba.sAndH) : m2.div)*ma.SR*m2.line_reset( (trigger,
                                                                                               rate : ba.sAndH), trigger);
      };
      zc_index_up(input, pos) = (  (input : ip.zc),
                                   (m2.diff(input) : >(0)) : &),
                                index : ba.sAndH,
                                pos : dl;
      zc_index_down(input, pos) =  (   (input : ip.zc),
                                       (m2.diff(input) : <(0)) : &),
                                   index : ba.sAndH,
                                   pos : dl;
      dl_pol(in, del) = de.fdelayltv(4, size, del, in);
      dl(in, del) = in : de.delay(size, del);
};

// Feedback delay network reverb with non-transposing variable DL
rev_fdn_smo(n, max_size, it, size, fb_coeff, cf, in) = (summing : delays :filters : matrix : fb : limiters) 
                                                       ~ si.bus(n) :> /(n)
with {
      summing = par(i, n, +(in));
      delays = par(i, n,   max_size, 
                           it,
                           (size : m2.prime_base_pow(i+1)),
                           _) : par(i, n, d2.del_smo);
      filters = par(i, n, f2.lp1p(cf));
      matrix = ro.hadamard(n);
      fb = par(i, n, *(fb_coeff));
      limiters = par(i, n, st.limiter(1));
};

// Feedback delay network reverb with variable DL
rev_fdn_pol(n, max_size, size, fb_coeff, cf, in) = (summing : delays :filters : matrix : fb : limiters) 
                                                   ~ si.bus(n) :> /(n)
with {
      summing = par(i, n, +(in));
      delays = par(i, n,   (_ <:   _,
                                   (size : m2.prime_base_pow(i+1)))) : par(i, n,   _, 
                                                                                   max_size,
                                                                                   _) : par(i, n, d2.del_pol);
      filters = par(i, n, f2.lp1p(cf));
      matrix = ro.hadamard(n);
      fb = par(i, n, *(fb_coeff));
      limiters = par(i, n, st.limiter(1));
};
